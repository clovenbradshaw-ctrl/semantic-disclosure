<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Client At-a-Glance</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #fafaf9;
      --bg-secondary: #f5f5f4;
      --bg-tertiary: #e7e5e4;
      --bg-card: #ffffff;
      --text-primary: #1c1917;
      --text-secondary: #57534e;
      --text-muted: #a8a29e;
      --border: #e7e5e4;
      --border-strong: #d6d3d1;
      --accent-blue: #0369a1;
      --accent-green: #15803d;
      --accent-amber: #b45309;
      --accent-rose: #be123c;
      --accent-violet: #7c3aed;
      --accent-slate: #475569;
      --shadow-sm: 0 1px 2px rgba(28, 25, 23, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(28, 25, 23, 0.07);
      --radius: 6px;
      --font-sans: 'IBM Plex Sans', -apple-system, sans-serif;
      --font-mono: 'IBM Plex Mono', monospace;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: var(--font-sans);
      background: var(--bg-primary);
      color: var(--text-primary);
      font-size: 14px;
      line-height: 1.5;
      padding: 16px;
    }

    .widget-container {
      max-width: 800px;
      margin: 0 auto;
    }

    /* Header Controls */
    .widget-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }

    .widget-title {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .view-toggle {
      display: flex;
      gap: 4px;
      background: var(--bg-secondary);
      padding: 3px;
      border-radius: var(--radius);
    }

    .view-toggle button {
      padding: 6px 12px;
      border: none;
      background: transparent;
      font-family: var(--font-sans);
      font-size: 13px;
      color: var(--text-secondary);
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.15s ease;
    }

    .view-toggle button.active {
      background: var(--bg-card);
      color: var(--text-primary);
      box-shadow: var(--shadow-sm);
    }

    .view-toggle button:hover:not(.active) {
      color: var(--text-primary);
    }

    /* Client Header Card */
    .client-header {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px 20px;
      margin-bottom: 16px;
      box-shadow: var(--shadow-sm);
    }

    .client-name {
      font-size: 20px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 4px;
    }

    .client-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      color: var(--text-secondary);
      font-size: 14px;
    }

    .client-meta-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .client-meta-label {
      color: var(--text-muted);
      font-size: 12px;
    }

    /* Narrative View */
    .narrative-view {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px 24px;
      margin-bottom: 16px;
      box-shadow: var(--shadow-sm);
    }

    .narrative-text {
      font-size: 15px;
      line-height: 1.7;
      color: var(--text-primary);
    }

    .narrative-text .provenance {
      font-size: 11px;
      color: var(--text-muted);
      vertical-align: super;
      margin-left: 2px;
      cursor: help;
    }

    /* Structured View */
    .structured-view {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .field-group {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      box-shadow: var(--shadow-sm);
    }

    .field-group-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      user-select: none;
      transition: background 0.15s ease;
    }

    .field-group-header:hover {
      background: var(--bg-tertiary);
    }

    .field-group-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
      font-size: 13px;
      color: var(--text-primary);
    }

    .field-group-count {
      font-size: 12px;
      color: var(--text-muted);
      font-weight: 400;
    }

    .field-group-chevron {
      color: var(--text-muted);
      transition: transform 0.2s ease;
      font-size: 12px;
    }

    .field-group.collapsed .field-group-chevron {
      transform: rotate(-90deg);
    }

    .field-group.collapsed .field-group-content {
      display: none;
    }

    .field-group-content {
      padding: 12px 16px;
    }

    /* Field Items */
    .field-item {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 8px 0;
      border-bottom: 1px solid var(--bg-secondary);
    }

    .field-item:last-child {
      border-bottom: none;
    }

    .field-label {
      font-size: 13px;
      color: var(--text-secondary);
      flex-shrink: 0;
      max-width: 45%;
    }

    .field-value {
      font-size: 13px;
      color: var(--text-primary);
      text-align: right;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .field-value a {
      color: var(--accent-blue);
      text-decoration: none;
    }

    .field-value a:hover {
      text-decoration: underline;
    }

    .field-value a.button-link {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      background: var(--bg-secondary);
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
      transition: background 0.15s ease;
    }

    .field-value a.button-link:hover {
      background: var(--bg-tertiary);
      text-decoration: none;
    }

    /* Provenance Badge */
    .provenance-badge {
      font-size: 10px;
      font-family: var(--font-mono);
      padding: 2px 6px;
      background: var(--bg-secondary);
      border-radius: 3px;
      color: var(--text-muted);
      white-space: nowrap;
    }

    /* Tier Indicators */
    .tier-indicator {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .tier-1 { background: var(--accent-green); }
    .tier-2 { background: var(--accent-blue); }
    .tier-3 { background: var(--accent-amber); }

    /* Uncategorized Section */
    .uncategorized-section {
      margin-top: 8px;
    }

    .uncategorized-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 14px;
      background: var(--bg-secondary);
      border: 1px dashed var(--border-strong);
      border-radius: var(--radius);
      cursor: pointer;
      font-size: 13px;
      color: var(--text-secondary);
      width: 100%;
      transition: all 0.15s ease;
    }

    .uncategorized-toggle:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .uncategorized-content {
      display: none;
      margin-top: 8px;
      padding: 12px 16px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
    }

    .uncategorized-content.visible {
      display: block;
    }

    /* Raw Triplet Display */
    .triplet {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 8px;
      padding: 6px 0;
      font-family: var(--font-mono);
      font-size: 12px;
      border-bottom: 1px solid var(--bg-secondary);
      align-items: center;
    }

    .triplet:last-child {
      border-bottom: none;
    }

    .triplet-source {
      color: var(--text-muted);
      font-size: 11px;
    }

    .triplet-field {
      color: var(--accent-violet);
    }

    .triplet-arrow {
      color: var(--text-muted);
    }

    .triplet-value {
      color: var(--text-primary);
      text-align: right;
      word-break: break-word;
    }

    /* Case Tabs */
    .case-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 12px;
      padding: 4px;
      background: var(--bg-secondary);
      border-radius: var(--radius);
      overflow-x: auto;
    }

    .case-tab {
      padding: 8px 14px;
      border: none;
      background: transparent;
      font-family: var(--font-sans);
      font-size: 13px;
      color: var(--text-secondary);
      cursor: pointer;
      border-radius: 4px;
      white-space: nowrap;
      transition: all 0.15s ease;
    }

    .case-tab.active {
      background: var(--bg-card);
      color: var(--text-primary);
      box-shadow: var(--shadow-sm);
    }

    .case-tab:hover:not(.active) {
      color: var(--text-primary);
    }

    .case-tab .case-count {
      font-size: 11px;
      color: var(--text-muted);
      margin-left: 6px;
    }

    /* Loading State */
    .loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 48px;
      color: var(--text-secondary);
    }

    .loading-spinner {
      width: 24px;
      height: 24px;
      border: 2px solid var(--border);
      border-top-color: var(--accent-blue);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-bottom: 12px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-detail {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 8px;
    }

    /* Error State */
    .error {
      padding: 24px;
      background: #fef2f2;
      border: 1px solid #fecaca;
      border-radius: var(--radius);
      color: #991b1b;
    }

    .error-title {
      font-weight: 600;
      margin-bottom: 4px;
    }

    /* Provenance Tooltip */
    .provenance-tooltip {
      position: absolute;
      background: var(--text-primary);
      color: white;
      padding: 8px 12px;
      border-radius: var(--radius);
      font-size: 12px;
      max-width: 250px;
      z-index: 1000;
      box-shadow: var(--shadow-md);
      pointer-events: none;
    }

    .provenance-tooltip::before {
      content: '';
      position: absolute;
      top: -6px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 6px solid var(--text-primary);
    }

    /* Settings Toggle */
    .settings-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }

    .settings-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--text-muted);
      cursor: pointer;
    }

    .settings-toggle input {
      cursor: pointer;
    }

    /* Empty State */
    .empty-state {
      padding: 32px;
      text-align: center;
      color: var(--text-muted);
    }

    /* Main Tabs - Top-level navigation */
    .main-tabs {
      display: flex;
      gap: 2px;
      margin-bottom: 16px;
      border-bottom: 2px solid var(--border);
    }

    .main-tab {
      padding: 10px 18px;
      border: none;
      background: transparent;
      font-family: var(--font-sans);
      font-size: 14px;
      font-weight: 500;
      color: var(--text-secondary);
      cursor: pointer;
      position: relative;
      transition: color 0.15s ease;
    }

    .main-tab:hover {
      color: var(--text-primary);
    }

    .main-tab.active {
      color: var(--accent-blue);
    }

    .main-tab.active::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--accent-blue);
    }

    .main-tab .tab-count {
      font-size: 11px;
      color: var(--text-muted);
      margin-left: 4px;
      font-weight: 400;
    }

    /* Tab Content */
    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Settings Panel */
    .settings-panel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      margin-bottom: 16px;
      overflow: hidden;
    }

    .settings-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: var(--bg-secondary);
      cursor: pointer;
      user-select: none;
    }

    .settings-panel-header:hover {
      background: var(--bg-tertiary);
    }

    .settings-panel-title {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .settings-panel-content {
      display: none;
      padding: 16px;
      border-top: 1px solid var(--border);
    }

    .settings-panel.open .settings-panel-content {
      display: block;
    }

    .field-checkbox-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 8px;
      max-height: 300px;
      overflow-y: auto;
    }

    .field-checkbox-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--bg-secondary);
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.15s ease;
    }

    .field-checkbox-item:hover {
      background: var(--bg-tertiary);
    }

    .field-checkbox-item input {
      cursor: pointer;
    }

    .field-checkbox-item .field-type {
      font-size: 10px;
      color: var(--text-muted);
      margin-left: auto;
    }

    .settings-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }

    .settings-btn {
      padding: 6px 12px;
      font-size: 12px;
      font-family: var(--font-sans);
      border: 1px solid var(--border);
      background: var(--bg-card);
      color: var(--text-secondary);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .settings-btn:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    .settings-btn.primary {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
    }

    .settings-btn.primary:hover {
      background: #0284c7;
    }

    /* No Data State */
    .no-data {
      padding: 24px;
      text-align: center;
      color: var(--text-muted);
      font-size: 13px;
    }

    /* Responsive */
    @media (max-width: 600px) {
      body {
        padding: 12px;
      }

      .field-item {
        flex-direction: column;
        gap: 4px;
      }

      .field-label {
        max-width: 100%;
      }

      .field-value {
        text-align: left;
      }

      .client-meta {
        flex-direction: column;
        gap: 8px;
      }

      .main-tabs {
        overflow-x: auto;
      }

      .main-tab {
        padding: 8px 12px;
        font-size: 13px;
        white-space: nowrap;
      }

      .field-checkbox-list {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>

<div class="widget-container" id="app">
  <div class="loading">
    <div class="loading-spinner"></div>
    <span>Loading client data...</span>
  </div>
</div>

<!-- Config loaded separately for easy updates -->
<script src="config.js"></script>

<script>
(function() {
  'use strict';

  // ==========================================================================
  // CONFIGURATION
  // ==========================================================================

  const WEBHOOK_URL = 'https://n8n.intelechia.com/webhook/c68fda2a-9302-4efb-930b-7063b85ef595';
  const CONFIG = typeof ClientGlanceConfig !== 'undefined' ? ClientGlanceConfig : null;

  // ==========================================================================
  // SCHEMA PROCESSOR
  // Dynamically analyzes Airtable schema to determine field types and groupings
  // ==========================================================================

  const SchemaProcessor = {
    schema: null,
    fieldMap: new Map(),      // fieldName -> { type, options, tableName }
    tableMap: new Map(),      // tableName -> { fields: [] }

    /**
     * Initialize with schema data from API
     * @param {Array} schemaData - Array of table definitions with fields
     */
    init(schemaData) {
      if (!schemaData || !Array.isArray(schemaData)) {
        console.log('[SchemaProcessor] No schema provided, using fallback mode');
        return false;
      }

      this.schema = schemaData;
      this.fieldMap.clear();
      this.tableMap.clear();

      // Build field map from schema
      for (const table of schemaData) {
        const tableName = table.name;
        this.tableMap.set(tableName, {
          id: table.id,
          fields: table.fields,
          primaryFieldId: table.primaryFieldId
        });

        for (const field of table.fields || []) {
          // Store field with table context
          this.fieldMap.set(field.name, {
            type: field.type,
            options: field.options || {},
            id: field.id,
            tableName
          });

          // Also store with table prefix for disambiguation
          this.fieldMap.set(`${tableName}::${field.name}`, {
            type: field.type,
            options: field.options || {},
            id: field.id,
            tableName
          });
        }
      }

      console.log(`[SchemaProcessor] Loaded ${this.fieldMap.size} fields from ${this.tableMap.size} tables`);
      return true;
    },

    /**
     * Get field metadata from schema
     */
    getFieldMeta(fieldName) {
      return this.fieldMap.get(fieldName) || null;
    },

    /**
     * Get Airtable field type (not our display type)
     */
    getFieldType(fieldName) {
      const meta = this.getFieldMeta(fieldName);
      return meta?.type || null;
    },

    /**
     * Map Airtable field type to display format
     */
    getDisplayType(fieldName, value) {
      const airtableType = this.getFieldType(fieldName);

      // Map Airtable types to display types
      const typeMap = {
        'date': 'date',
        'dateTime': 'datetime',
        'createdTime': 'datetime',
        'lastModifiedTime': 'datetime',
        'email': 'email',
        'url': 'url',
        'phone': 'phone',  // Airtable doesn't have phone type, but we handle it
        'phoneNumber': 'phone',
        'checkbox': 'boolean',
        'number': 'number',
        'currency': 'currency',
        'percent': 'percent',
        'rating': 'rating',
        'duration': 'duration',
        'singleSelect': 'select',
        'multipleSelects': 'multiselect',
        'multipleRecordLinks': 'linked_records',
        'multipleLookupValues': 'lookup',
        'rollup': 'rollup',
        'formula': this.inferFormulaType.bind(this),
        'button': 'button',
        'multipleAttachments': 'attachment',
        'richText': 'richtext',
        'multilineText': 'text',
        'singleLineText': 'text',
        'autoNumber': 'number',
        'barcode': 'text',
        'lastModifiedBy': 'user',
        'createdBy': 'user'
      };

      const mapped = typeMap[airtableType];
      if (typeof mapped === 'function') {
        return mapped(fieldName, value);
      }
      return mapped || null;
    },

    /**
     * Infer type from formula result
     */
    inferFormulaType(fieldName, value) {
      const meta = this.getFieldMeta(fieldName);
      const resultType = meta?.options?.result?.type;

      if (resultType) {
        // Map the result type
        if (resultType === 'dateTime' || resultType === 'date') return 'date';
        if (resultType === 'number') return 'number';
        if (resultType === 'checkbox') return 'boolean';
      }

      // Fall back to value inference
      return null;
    },

    /**
     * Infer group from field name and type
     */
    inferGroup(fieldName, fieldType) {
      // First check schema-based grouping patterns
      const schemaGroups = this.getSchemaBasedGroup(fieldName);
      if (schemaGroups) return schemaGroups;

      // Immigration domain-specific patterns
      const fieldLower = fieldName.toLowerCase();

      // Court/Hearing related
      if (/hearing|court|judge|eoir|ich|merits|pleading|nta|calendar/.test(fieldLower)) {
        return 'Court';
      }

      // SIJ related
      if (/\bsij|custody|jdr|juvenile|child/.test(fieldLower)) {
        return 'SIJ';
      }

      // USCIS related
      if (/uscis|i-\d{3}|receipt|biometric|rfe|rfi|filing/.test(fieldLower)) {
        return 'USCIS';
      }

      // EAD related
      if (/\bead\b|work.*auth|employment.*auth/.test(fieldLower)) {
        return 'EAD';
      }

      // FOIA/Records
      if (/foia|fbi|obim|ice.*record|cbp.*record/.test(fieldLower)) {
        return 'Records';
      }

      // Appeals
      if (/appeal|brief|bia|circuit/.test(fieldLower)) {
        return 'Appeals';
      }

      // U-Visa
      if (/u-visa|u visa|uvisa|certification.*status/.test(fieldLower)) {
        return 'U-Visa';
      }

      // Asylum
      if (/asylum|i-589|credible.*fear|fear.*interview/.test(fieldLower)) {
        return 'Asylum';
      }

      // Bond
      if (/bond|detention|ice.*custody/.test(fieldLower)) {
        return 'Bond';
      }

      // Contact Info
      if (/phone|email|address|city|state|zip|contact/.test(fieldLower)) {
        return 'Contact';
      }

      // Identity
      if (/\bname\b|dob|birth|age|country|a#|a-number|gender|pronoun/.test(fieldLower)) {
        return 'Identity';
      }

      // Management
      if (/manager|attorney|atty|assigned|status|tag|case.*manager/.test(fieldLower)) {
        return 'Management';
      }

      // Documents/Links
      if (/document|file|box|link|url|scan|attachment/.test(fieldLower)) {
        return 'Documents';
      }

      // Notes
      if (/note|comment|memo/.test(fieldLower)) {
        return 'Notes';
      }

      // Financial
      if (/contract|payment|invoice|fee|retainer|\$|amount|price/.test(fieldLower)) {
        return 'Financial';
      }

      // Dates (generic)
      if (/date|time|deadline|due/.test(fieldLower) && fieldType === 'date') {
        return 'Dates';
      }

      return null;
    },

    /**
     * Use schema relationships to infer grouping
     */
    getSchemaBasedGroup(fieldName) {
      const meta = this.getFieldMeta(fieldName);
      if (!meta) return null;

      // If it's a lookup or rollup, try to get group from the linked table
      if (meta.type === 'multipleLookupValues' || meta.type === 'rollup') {
        const linkedFieldId = meta.options?.recordLinkFieldId;
        // Could trace back to linked table for grouping, but keep simple for now
      }

      return null;
    },

    /**
     * Get select options for a field
     */
    getSelectOptions(fieldName) {
      const meta = this.getFieldMeta(fieldName);
      if (!meta?.options?.choices) return null;
      return meta.options.choices.map(c => ({ id: c.id, name: c.name, color: c.color }));
    },

    /**
     * Check if field should be hidden based on schema
     */
    shouldHideField(fieldName) {
      const meta = this.getFieldMeta(fieldName);
      if (!meta) return false;

      // Hide internal/system fields
      const hiddenTypes = ['lastModifiedBy', 'createdBy', 'autoNumber'];
      if (hiddenTypes.includes(meta.type)) return true;

      // Hide fields that are purely internal
      const hiddenPatterns = [
        /^record.*id$/i,
        /^airtable.*id$/i,
        /_id$/i,
        /^id$/i,
        /sync|push|calc|internal/i
      ];

      return hiddenPatterns.some(p => p.test(fieldName));
    },

    /**
     * Generate a smart display label for a field
     */
    getDisplayLabel(fieldName) {
      // Remove common suffixes
      let label = fieldName
        .replace(/\s*\(from.*\)$/i, '')  // Remove "(from Table)" lookups
        .replace(/_/g, ' ')
        .replace(/([A-Z])/g, ' $1')
        .trim();

      // Capitalize first letter
      return label.charAt(0).toUpperCase() + label.slice(1);
    },

    /**
     * Get all fields for a table
     */
    getTableFields(tableName) {
      const table = this.tableMap.get(tableName);
      return table?.fields || [];
    },

    /**
     * Check if schema is loaded
     */
    hasSchema() {
      return this.schema !== null && this.fieldMap.size > 0;
    }
  };

  // ==========================================================================
  // FIELD PREFERENCES
  // Manages user preferences for which fields to show in each tab
  // Stored in localStorage
  // ==========================================================================

  const FieldPreferences = {
    storageKey: CONFIG?.STORAGE_KEY || 'clientGlance_fieldPrefs',
    preferences: null,

    /**
     * Load preferences from localStorage or use defaults
     */
    load() {
      try {
        const stored = localStorage.getItem(this.storageKey);
        if (stored) {
          this.preferences = JSON.parse(stored);
          console.log('[FieldPreferences] Loaded from localStorage');
        } else {
          this.preferences = this.getDefaults();
          console.log('[FieldPreferences] Using defaults');
        }
      } catch (e) {
        console.warn('[FieldPreferences] Error loading preferences:', e.message);
        this.preferences = this.getDefaults();
      }
      return this.preferences;
    },

    /**
     * Get default field visibility from config
     */
    getDefaults() {
      const defaults = {};
      const tabs = CONFIG?.MAIN_TABS || {};

      for (const [tabId, tabConfig] of Object.entries(tabs)) {
        defaults[tabId] = {
          visibleFields: [...(tabConfig.defaultFields || [])],
          hiddenFields: [...(tabConfig.alwaysHidden || [])]
        };
      }

      return defaults;
    },

    /**
     * Save preferences to localStorage
     */
    save() {
      try {
        localStorage.setItem(this.storageKey, JSON.stringify(this.preferences));
        console.log('[FieldPreferences] Saved to localStorage');
      } catch (e) {
        console.warn('[FieldPreferences] Error saving preferences:', e.message);
      }
    },

    /**
     * Reset to defaults
     */
    reset() {
      this.preferences = this.getDefaults();
      this.save();
      return this.preferences;
    },

    /**
     * Check if a field should be visible in a tab
     */
    isFieldVisible(tabId, fieldName) {
      if (!this.preferences) this.load();

      const tabPrefs = this.preferences[tabId];
      if (!tabPrefs) return true;

      // Always hidden fields are never shown
      if (tabPrefs.hiddenFields?.includes(fieldName)) return false;

      // Check if in visible list
      return tabPrefs.visibleFields?.includes(fieldName) ?? false;
    },

    /**
     * Toggle field visibility
     */
    toggleField(tabId, fieldName, visible) {
      if (!this.preferences) this.load();

      if (!this.preferences[tabId]) {
        this.preferences[tabId] = { visibleFields: [], hiddenFields: [] };
      }

      const visibleFields = this.preferences[tabId].visibleFields || [];

      if (visible && !visibleFields.includes(fieldName)) {
        visibleFields.push(fieldName);
      } else if (!visible) {
        const idx = visibleFields.indexOf(fieldName);
        if (idx > -1) visibleFields.splice(idx, 1);
      }

      this.preferences[tabId].visibleFields = visibleFields;
      this.save();
    },

    /**
     * Get all visible fields for a tab
     */
    getVisibleFields(tabId) {
      if (!this.preferences) this.load();
      return this.preferences[tabId]?.visibleFields || [];
    },

    /**
     * Set visible fields for a tab (batch update)
     */
    setVisibleFields(tabId, fieldNames) {
      if (!this.preferences) this.load();

      if (!this.preferences[tabId]) {
        this.preferences[tabId] = { visibleFields: [], hiddenFields: [] };
      }

      this.preferences[tabId].visibleFields = [...fieldNames];
      this.save();
    },

    /**
     * Check if a field should always be hidden (internal fields)
     */
    isAlwaysHidden(tabId, fieldName) {
      const tabConfig = CONFIG?.MAIN_TABS?.[tabId];
      if (!tabConfig) return false;

      return tabConfig.alwaysHidden?.some(pattern => {
        if (pattern instanceof RegExp) {
          return pattern.test(fieldName);
        }
        return pattern === fieldName;
      }) ?? false;
    }
  };

  // ==========================================================================
  // DATA TRANSFORMER
  // Converts flat API array format to normalized clientInfo/cases structure
  // ==========================================================================

  const DataTransformer = {
    /**
     * Transform raw API response (flat array of case records) into normalized format
     * @param {Array|Object} rawData - Raw webhook response
     * @returns {Object} Normalized { clientInfo, cases } structure
     */
    transform(rawData) {
      // Handle response with schema included: { schema: [...], data: [...] }
      if (rawData && rawData.schema && Array.isArray(rawData.schema)) {
        console.log('[DataTransformer] Schema detected in response');
        SchemaProcessor.init(rawData.schema);
        rawData = rawData.data || rawData.records || [];
      }

      // Handle already-normalized data with potential schema
      if (rawData && rawData.clientInfo) {
        // Check if schema is embedded
        if (rawData.schema) {
          SchemaProcessor.init(rawData.schema);
        }
        return rawData;
      }

      // Handle flat array of records (actual Airtable format)
      if (!Array.isArray(rawData) || rawData.length === 0) {
        console.warn('[DataTransformer] Empty or invalid data received');
        return { clientInfo: { fields: {} }, cases: [] };
      }

      // Filter out empty objects from the array
      const records = rawData.filter(record =>
        record && typeof record === 'object' && Object.keys(record).length > 0
      );

      if (records.length === 0) {
        console.warn('[DataTransformer] No valid records after filtering');
        return { clientInfo: { fields: {} }, cases: [] };
      }

      // Identify Client Info record vs Case records
      // Client Info records have unique fields like "Full Client Name", "Address Line 1", etc.
      const { clientInfoRecord, caseRecords } = this.separateRecordTypes(records);

      // Extract client fields from the appropriate source
      const clientFields = clientInfoRecord
        ? this.extractClientFieldsFromClientInfo(clientInfoRecord)
        : this.extractClientFields(caseRecords[0] || {});

      // Transform case records
      const cases = caseRecords.map((record, index) => this.transformCase(record, index));

      return {
        clientInfo: {
          recordId: clientInfoRecord?.id ||
                    clientInfoRecord?.recordId ||
                    this.unwrapValue(caseRecords[0]?.['Client_ID_Airtable']) ||
                    caseRecords[0]?.id,
          fields: clientFields
        },
        cases
      };
    },

    /**
     * Separate Client Info records from Case Master View records
     * Uses _sourceTable field when available, falls back to field-based heuristics
     */
    separateRecordTypes(records) {
      let clientInfoRecord = null;
      const caseRecords = [];

      for (const record of records) {
        const sourceTable = record._sourceTable;

        // Primary detection: use _sourceTable field if available
        if (sourceTable) {
          const tableLower = sourceTable.toLowerCase();
          if (tableLower.includes('client info') && !tableLower.includes('case') && !tableLower.includes('master')) {
            clientInfoRecord = record;
            console.log(`[DataTransformer] Client Info record via _sourceTable: ${sourceTable}`);
            continue;
          }
          // Otherwise it's a case record - continue to add below
        } else {
          // Fallback: field-based heuristics for older response formats
          const clientInfoIndicators = [
            'Full Client Name', 'Full_Name_Normal_Pretty', 'Address Line 1',
            'City', 'Zip (5)', 'PPID', 'Softr Client Page', 'Gmail_Search_Terms',
            'Box_Folder_ID', 'Client Details Page', 'airtable_client_info_id'
          ];
          const caseIndicators = [
            'Case Notes', 'Activity', 'Details', 'Matter_Flatpack',
            'Case Master View Record ID', 'Appeal Engagement Deadline'
          ];

          const hasClientInfoFields = clientInfoIndicators.some(f => record[f] !== undefined);
          const hasCaseFields = caseIndicators.some(f => record[f] !== undefined);

          if (hasClientInfoFields && !hasCaseFields) {
            clientInfoRecord = record;
            console.log('[DataTransformer] Client Info record via field heuristics');
            continue;
          }
        }

        // Default: treat as Case Master View record
        caseRecords.push(record);
      }

      console.log(`[DataTransformer] Found ${caseRecords.length} case records, clientInfo: ${clientInfoRecord ? 'yes' : 'no'}`);
      return { clientInfoRecord, caseRecords };
    },

    /**
     * Extract client fields from a dedicated Client Info record
     * Maps field names from Client Info table format to expected format
     */
    extractClientFieldsFromClientInfo(record) {
      // Map Client Info table field names to standard display names
      const fieldMappings = {
        'Full Client Name': 'Client Name',
        'Client Name': 'Client Name',
        'First Name': 'First Name',
        'Family Name': 'Family Name',
        'Middle Name': 'Middle Name',
        'A#': 'A#',
        'DOB': 'DOB',
        'Age': 'Age',
        'Country': 'Country',
        'Phone Number': 'Phone Number',
        'Phone Reformat 3 (xxx) xxx-xxxx': 'Phone Number',
        'Client Email': 'Client Email',
        'Address Formula': 'Address',
        'Address': 'Address',
        'Gender': 'Gender',
        'Pronouns': 'Pronouns',
        'Detained': 'Detained',
        'Detainment Status / Location': 'Detention Location'
      };

      const fields = {};

      for (const [sourceField, targetField] of Object.entries(fieldMappings)) {
        if (record[sourceField] !== undefined && !fields[targetField]) {
          const value = this.normalizeValue(record[sourceField], sourceField);
          if (value !== null) {
            fields[targetField] = value;
          }
        }
      }

      return fields;
    },

    /**
     * Extract client-level fields from a record
     */
    extractClientFields(record) {
      const clientFieldNames = [
        'Client Name', 'First Name', 'Family Name', 'Middle Name',
        'A#', 'DOB', 'Age', 'Country', 'Phone Number', 'Client Email',
        'Address', 'Gender', 'Pronouns'
      ];

      const fields = {};
      for (const fieldName of clientFieldNames) {
        if (record[fieldName] !== undefined) {
          const value = this.normalizeValue(record[fieldName], fieldName);
          if (value !== null) {
            fields[fieldName] = value;
          }
        }
      }
      return fields;
    },

    /**
     * Transform a single case record
     */
    transformCase(record, index) {
      const caseIdentifier = this.deriveCaseIdentifier(record, index);
      const fields = {};

      // Client fields to exclude from case
      const clientOnlyFields = new Set([
        'Client Name', 'First Name', 'Family Name', 'Middle Name',
        'A#', 'DOB', 'Age', 'Country', 'Phone Number', 'Client Email',
        'Address', 'Client_ID_Airtable', 'Edit Client Info', 'Gender', 'Pronouns'
      ]);

      for (const [fieldName, rawValue] of Object.entries(record)) {
        // Skip client-only fields (they go in clientInfo)
        if (clientOnlyFields.has(fieldName)) continue;

        // Skip metadata fields
        if (fieldName === 'id' || fieldName === 'createdTime') continue;

        const value = this.normalizeValue(rawValue, fieldName);
        if (value !== null) {
          fields[fieldName] = value;
        }
      }

      return {
        recordId: record.id || record['Case Master View Record ID'] || `case-${index}`,
        caseIdentifier,
        fields
      };
    },

    /**
     * Derive a human-readable case identifier
     */
    deriveCaseIdentifier(record, index) {
      // Try Description field first (e.g., "EAD (0)", "Defensive Asylum (1000)")
      if (record.Description) {
        return this.cleanCaseDescription(record.Description);
      }

      // Try Matter_Flatpack JSON
      if (record.Matter_Flatpack) {
        try {
          const matter = typeof record.Matter_Flatpack === 'string'
            ? JSON.parse(record.Matter_Flatpack)
            : record.Matter_Flatpack;
          if (matter.description) {
            return this.cleanCaseDescription(matter.description);
          }
        } catch (e) { /* ignore parse errors */ }
      }

      // Fallback to generic label
      return `Case ${index + 1}`;
    },

    /**
     * Clean up case description for display
     */
    cleanCaseDescription(desc) {
      // Remove parenthetical numbers like "(0)", "(1000)"
      return desc.replace(/\s*\(\d+\)\s*$/, '').trim() || desc;
    },

    /**
     * Normalize a field value - unwrap arrays, filter errors, extract buttons
     */
    normalizeValue(rawValue, fieldName) {
      // Handle null/undefined
      if (rawValue === null || rawValue === undefined || rawValue === '') {
        return null;
      }

      // Handle booleans
      if (typeof rawValue === 'boolean') {
        return rawValue ? 'Yes' : 'No';
      }

      // Handle error objects
      if (typeof rawValue === 'object' && rawValue !== null && !Array.isArray(rawValue)) {
        if (rawValue.error || rawValue.specialValue === 'NaN') {
          return null; // Filter out errors and NaN
        }

        // Handle button objects { label, url }
        if (rawValue.label !== undefined && rawValue.url !== undefined) {
          // Only keep buttons with actual URLs
          if (rawValue.url && rawValue.url.trim()) {
            return { type: 'button', label: rawValue.label, url: rawValue.url };
          }
          return null;
        }

        // Handle user objects { id, email, name }
        if (rawValue.id && rawValue.name && rawValue.email) {
          return rawValue.name;
        }

        // Handle attachment objects { id, url, filename, type }
        if (rawValue.url && rawValue.filename) {
          return {
            type: 'attachment',
            label: rawValue.filename,
            url: rawValue.url,
            fileType: rawValue.type || 'file'
          };
        }
      }

      // Handle arrays
      if (Array.isArray(rawValue)) {
        // Filter out null, undefined, empty strings
        const filtered = rawValue.filter(v => v !== null && v !== undefined && v !== '');
        if (filtered.length === 0) return null;

        // Check if it's an array of attachments
        if (filtered[0] && typeof filtered[0] === 'object' && filtered[0].url && filtered[0].filename) {
          // Return first attachment as button-like object
          return {
            type: 'attachment',
            label: filtered[0].filename,
            url: filtered[0].url,
            fileType: filtered[0].type || 'file'
          };
        }

        // Single element - recursively normalize
        if (filtered.length === 1) {
          return this.normalizeValue(filtered[0], fieldName);
        }

        // Multi-element arrays: join if all strings/numbers (excluding record IDs)
        if (filtered.every(v => typeof v === 'string' || typeof v === 'number')) {
          // Skip if they look like record IDs
          if (filtered.every(v => /^rec[a-zA-Z0-9]+$/.test(String(v)))) {
            return null; // Don't display raw record IDs
          }
          return filtered.join(', ');
        }

        // Otherwise return as-is for complex arrays
        return filtered;
      }

      return rawValue;
    },

    /**
     * Unwrap a value that might be array-wrapped
     */
    unwrapValue(value) {
      if (Array.isArray(value) && value.length > 0) {
        return value[0];
      }
      return value;
    }
  };

  // ==========================================================================
  // UTILITIES
  // ==========================================================================

  // Store recordId received via postMessage (for iframe embedding)
  let postMessageRecordId = null;

  // Listen for postMessage from parent window (for iframe embedding)
  window.addEventListener('message', (event) => {
    // Accept messages with recordId
    if (event.data && event.data.type === 'recordId' && event.data.recordId) {
      console.log('[ClientGlance] Received recordId via postMessage:', event.data.recordId);
      postMessageRecordId = event.data.recordId;

      // If widget already showed "No Record ID" error, re-initialize
      const container = document.getElementById('app');
      if (container && container.querySelector('.error')) {
        init();
      }
    }
  });

  const Utils = {
    // Get recordId from URL params (Softr passes this) or postMessage
    getRecordId() {
      // First, check if we received recordId via postMessage
      if (postMessageRecordId) {
        return postMessageRecordId;
      }

      try {
        const params = new URLSearchParams(window.location.search);
        return params.get('recordId') || params.get('record_id') || params.get('id');
      } catch (e) {
        // Handle cross-origin iframe SecurityError
        console.warn('[ClientGlance] Cannot access window.location (cross-origin iframe):', e.message);
        return null;
      }
    },

    // Format date
    formatDate(value, includeTime = false) {
      try {
        const date = new Date(value);
        if (isNaN(date.getTime())) return value;
        
        const options = includeTime 
          ? CONFIG?.DISPLAY?.dateTimeFormat || { year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' }
          : CONFIG?.DISPLAY?.dateFormat || { year: 'numeric', month: 'short', day: 'numeric' };
        
        return date.toLocaleDateString('en-US', options);
      } catch {
        return value;
      }
    },

    // Format phone
    formatPhone(value) {
      const cleaned = String(value).replace(/\D/g, '');
      if (cleaned.length === 10) {
        return `(${cleaned.slice(0,3)}) ${cleaned.slice(3,6)}-${cleaned.slice(6)}`;
      }
      return value;
    },

    // Humanize field name
    humanizeFieldName(name) {
      return name
        .replace(/([A-Z])/g, ' $1')
        .replace(/_/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .replace(/^./, s => s.toUpperCase());
    },

    // Apply template with value
    applyTemplate(template, value, dataType) {
      let formattedValue = value;
      
      // Handle template format specifiers
      if (template.includes('{value:date}')) {
        formattedValue = this.formatDate(value);
        return template.replace('{value:date}', formattedValue);
      }
      if (template.includes('{value:datetime}')) {
        formattedValue = this.formatDate(value, true);
        return template.replace('{value:datetime}', formattedValue);
      }
      if (template.includes('{value:phone}')) {
        formattedValue = this.formatPhone(value);
        return template.replace('{value:phone}', formattedValue);
      }
      if (template.includes('{value:lowercase}')) {
        formattedValue = String(value).toLowerCase();
        return template.replace('{value:lowercase}', formattedValue);
      }
      
      return template.replace('{value}', value);
    },

    // Infer data type from value and optionally schema
    inferDataType(value, fieldName = null) {
      // First, try schema-based detection
      if (fieldName && SchemaProcessor.hasSchema()) {
        const schemaType = SchemaProcessor.getDisplayType(fieldName, value);
        if (schemaType) return schemaType;
      }

      // Fall back to pattern-based detection
      if (!value || typeof value !== 'string') return null;

      const patterns = CONFIG?.DATA_TYPE_PATTERNS || [];
      for (const { type, pattern, minLength } of patterns) {
        if (pattern.test(value)) {
          if (minLength && value.length < minLength) continue;
          return type;
        }
      }
      return null;
    },

    // Format value by inferred type
    formatByType(value, type) {
      switch (type) {
        case 'date': return this.formatDate(value);
        case 'datetime': return this.formatDate(value, true);
        case 'phone': return this.formatPhone(value);
        case 'boolean': return value.toLowerCase() === 'true' || value.toLowerCase() === 'yes' ? 'Yes' : 'No';
        case 'url': return value;
        default: return value;
      }
    },

    // Check if field should be hidden
    isHiddenField(fieldName) {
      // Check schema-based hiding first
      if (SchemaProcessor.hasSchema() && SchemaProcessor.shouldHideField(fieldName)) {
        return true;
      }

      const hiddenPatterns = CONFIG?.DISPLAY?.hiddenFields || [];
      return hiddenPatterns.some(pattern => {
        if (pattern instanceof RegExp) return pattern.test(fieldName);
        return fieldName === pattern;
      });
    },

    // Find group by pattern matching (with schema support)
    findGroupByPattern(fieldName) {
      // First, try schema-based grouping
      if (SchemaProcessor.hasSchema()) {
        const fieldType = SchemaProcessor.getFieldType(fieldName);
        const schemaGroup = SchemaProcessor.inferGroup(fieldName, fieldType);
        if (schemaGroup) return schemaGroup;
      }

      // Fall back to config patterns
      const patterns = CONFIG?.FIELD_GROUP_PATTERNS || [];
      for (const { group, pattern } of patterns) {
        if (pattern.test(fieldName)) return group;
      }
      return null;
    },

    // Escape HTML
    escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }
  };

  // ==========================================================================
  // DATA PROCESSOR
  // ==========================================================================

  const DataProcessor = {
    // Pronoun context for narrative composition
    pronounContext: {
      subject: 'They',      // He/She/They
      object: 'them',       // him/her/them
      possessive: 'their',  // his/her/their
      reflexive: 'themselves' // himself/herself/themselves
    },

    /**
     * Set pronouns based on client data
     */
    setPronouns(clientFields) {
      const gender = clientFields?.Gender?.toLowerCase?.();
      const pronounsField = clientFields?.Pronouns?.toLowerCase?.();

      // Check explicit pronouns field first
      if (pronounsField) {
        if (pronounsField.includes('she') || pronounsField.includes('her')) {
          this.pronounContext = { subject: 'She', object: 'her', possessive: 'her', reflexive: 'herself' };
        } else if (pronounsField.includes('he') || pronounsField.includes('him')) {
          this.pronounContext = { subject: 'He', object: 'him', possessive: 'his', reflexive: 'himself' };
        } else {
          // Default to They for they/them or unknown
          this.pronounContext = { subject: 'They', object: 'them', possessive: 'their', reflexive: 'themselves' };
        }
        return;
      }

      // Fall back to gender field
      if (gender === 'female' || gender === 'f') {
        this.pronounContext = { subject: 'She', object: 'her', possessive: 'her', reflexive: 'herself' };
      } else if (gender === 'male' || gender === 'm') {
        this.pronounContext = { subject: 'He', object: 'him', possessive: 'his', reflexive: 'himself' };
      } else {
        // Default to gender-neutral
        this.pronounContext = { subject: 'They', object: 'them', possessive: 'their', reflexive: 'themselves' };
      }
    },

    // Process raw webhook response into tiered fields
    processFields(rawData) {
      // Transform flat array format to normalized structure
      const normalizedData = DataTransformer.transform(rawData);
      const processed = [];

      // Set pronouns from client data
      this.setPronouns(normalizedData.clientInfo?.fields);

      // Process client info fields
      if (normalizedData.clientInfo) {
        this.processRecord(normalizedData.clientInfo, 'Client Info', null, processed);
      }

      // Process case master view records
      if (normalizedData.cases && Array.isArray(normalizedData.cases)) {
        normalizedData.cases.forEach((caseRecord, index) => {
          const caseLabel = caseRecord.caseIdentifier || `Case ${index + 1}`;
          this.processRecord(caseRecord.fields || caseRecord, 'Case Master View', caseLabel, processed);
        });
      }

      return processed;
    },

    processRecord(record, sourceTable, caseLabel, results) {
      const fields = record.fields || record;
      
      Object.entries(fields).forEach(([fieldName, value]) => {
        // Skip empty values
        if (value === null || value === undefined || value === '') return;
        if (Array.isArray(value) && value.length === 0) return;
        
        // Skip hidden fields
        if (Utils.isHiddenField(fieldName)) return;
        
        // Skip record metadata
        if (fieldName === 'recordId' || fieldName === 'caseIdentifier') return;
        
        const processedField = this.processField(fieldName, value, sourceTable, caseLabel, record.recordId);
        if (processedField) {
          results.push(processedField);
        }
      });
    },

    processField(fieldName, value, sourceTable, caseLabel, recordId) {
      const semanticConfig = CONFIG?.SEMANTIC_ROLES?.[fieldName];

      // Handle button objects specially
      if (value && typeof value === 'object' && value.type === 'button') {
        return {
          tier: 2,
          fieldName,
          value: value.url,
          rendered: value.label || fieldName,
          role: null,
          group: Utils.findGroupByPattern(fieldName) || 'Documents',
          priority: 50,
          narrativePosition: null,
          dataType: 'button',
          buttonLabel: value.label,
          buttonUrl: value.url,
          sourceTable,
          caseLabel,
          recordId
        };
      }

      // Handle attachment objects specially
      if (value && typeof value === 'object' && value.type === 'attachment') {
        return {
          tier: 2,
          fieldName,
          value: value.url,
          rendered: value.label || 'Download',
          role: null,
          group: Utils.findGroupByPattern(fieldName) || 'Documents',
          priority: 50,
          narrativePosition: null,
          dataType: 'attachment',
          buttonLabel: value.label,
          buttonUrl: value.url,
          fileType: value.fileType,
          sourceTable,
          caseLabel,
          recordId
        };
      }

      // Stringify complex values
      let displayValue = value;
      if (Array.isArray(value)) {
        displayValue = value.join(', ');
      } else if (typeof value === 'object' && value !== null) {
        // Skip error/NaN objects that slipped through
        if (value.error || value.specialValue) {
          return null;
        }
        displayValue = JSON.stringify(value);
      }
      
      // Tier 1: Semantic role defined
      if (semanticConfig) {
        const rendered = Utils.applyTemplate(semanticConfig.template, displayValue, semanticConfig.dataType);
        return {
          tier: 1,
          fieldName,
          value: displayValue,
          rendered,
          role: semanticConfig.role,
          group: semanticConfig.group,
          priority: semanticConfig.priority || 99,
          narrativePosition: semanticConfig.narrativePosition,
          dataType: semanticConfig.dataType,
          sourceTable,
          caseLabel,
          recordId
        };
      }
      
      // Tier 2: Schema-informed or pattern-matched processing
      // Use schema type first, then fall back to pattern matching
      const schemaType = SchemaProcessor.hasSchema()
        ? SchemaProcessor.getDisplayType(fieldName, displayValue)
        : null;
      const inferredType = schemaType || Utils.inferDataType(String(displayValue), fieldName);
      const group = Utils.findGroupByPattern(fieldName);

      // If we have schema info OR can match patterns, use Tier 2
      if (group || inferredType || SchemaProcessor.hasSchema()) {
        const formatted = inferredType ? Utils.formatByType(displayValue, inferredType) : displayValue;
        const displayLabel = SchemaProcessor.hasSchema()
          ? SchemaProcessor.getDisplayLabel(fieldName)
          : Utils.humanizeFieldName(fieldName);

        return {
          tier: 2,
          fieldName,
          displayLabel,
          value: displayValue,
          rendered: formatted,
          role: null,
          group: group || (SchemaProcessor.hasSchema() ? 'Other' : 'Other'),
          priority: this.calculatePriority(fieldName, inferredType),
          narrativePosition: null,
          dataType: inferredType,
          schemaType: SchemaProcessor.getFieldType(fieldName),
          sourceTable,
          caseLabel,
          recordId
        };
      }

      // Tier 3: Raw triplet (fallback when no schema and no pattern match)
      return {
        tier: 3,
        fieldName,
        displayLabel: Utils.humanizeFieldName(fieldName),
        value: displayValue,
        rendered: String(displayValue),
        role: null,
        group: 'Uncategorized',
        priority: 99,
        narrativePosition: null,
        dataType: null,
        schemaType: null,
        sourceTable,
        caseLabel,
        recordId
      };
    },

    /**
     * Calculate field priority for display ordering
     * Lower numbers = higher priority (shown first)
     */
    calculatePriority(fieldName, dataType) {
      const fieldLower = fieldName.toLowerCase();

      // Dates are important - show early
      if (dataType === 'date' || dataType === 'datetime') {
        // Upcoming/due dates first
        if (/due|upcoming|next|hearing|deadline/.test(fieldLower)) return 10;
        // Other dates
        return 30;
      }

      // Status fields are important
      if (/status|stage|decision/.test(fieldLower)) return 20;

      // Receipt numbers and IDs
      if (/receipt|number|#/.test(fieldLower)) return 40;

      // Notes and comments go later
      if (/note|comment|memo/.test(fieldLower)) return 80;

      // Default priority
      return 50;
    },

    // Compose narrative from Tier 1 fields
    composeNarrative(fields) {
      const tier1 = fields.filter(f => f.tier === 1);
      const templates = CONFIG?.NARRATIVE_TEMPLATES || {};
      const pronouns = this.pronounContext;

      const sentences = [];

      // Sort templates by order
      const orderedTemplates = Object.entries(templates)
        .sort(([,a], [,b]) => a.order - b.order);

      for (const [name, template] of orderedTemplates) {
        try {
          const sentence = template.compose(tier1, pronouns);
          if (sentence) {
            sentences.push(sentence);
          }
        } catch (e) {
          console.warn(`Error composing ${name} narrative:`, e);
        }
      }

      // Add remaining Tier 1 fields not in narrative templates
      const usedRoles = new Set(tier1.filter(f => f.narrativePosition).map(f => f.role));
      const unusedTier1 = tier1.filter(f => !usedRoles.has(f.role) && f.role !== 'client_name' && f.role !== 'a_number' && f.role !== 'date_of_birth' && f.role !== 'country_of_origin');

      if (unusedTier1.length > 0) {
        const grouped = {};
        unusedTier1.forEach(f => {
          if (!grouped[f.group]) grouped[f.group] = [];
          grouped[f.group].push(f);
        });

        Object.entries(grouped).forEach(([group, items]) => {
          const parts = items.slice(0, 3).map(i => i.rendered);
          if (parts.length) {
            sentences.push(`${group}: ${parts.join(', ')}`);
          }
        });
      }

      return sentences.join('. ') + (sentences.length ? '.' : '');
    },

    // Group fields for structured view
    groupFields(fields) {
      const groups = {};
      
      fields.forEach(field => {
        const groupName = field.group || 'Uncategorized';
        if (!groups[groupName]) {
          groups[groupName] = [];
        }
        groups[groupName].push(field);
      });
      
      // Sort fields within each group
      Object.values(groups).forEach(groupFields => {
        groupFields.sort((a, b) => {
          if (a.tier !== b.tier) return a.tier - b.tier;
          return a.priority - b.priority;
        });
      });
      
      // Sort groups by configured order
      const groupOrder = CONFIG?.GROUP_ORDER || [];
      const sortedGroups = {};
      
      groupOrder.forEach(groupName => {
        if (groups[groupName]) {
          sortedGroups[groupName] = groups[groupName];
        }
      });
      
      // Add any remaining groups not in order
      Object.keys(groups).forEach(groupName => {
        if (!sortedGroups[groupName]) {
          sortedGroups[groupName] = groups[groupName];
        }
      });
      
      return sortedGroups;
    },

    // Extract header fields
    extractHeaderFields(fields) {
      const headerRoles = CONFIG?.DISPLAY?.headerFields || ['client_name', 'a_number', 'dob'];
      return fields.filter(f => headerRoles.includes(f.role));
    }
  };

  // ==========================================================================
  // RENDERER
  // ==========================================================================

  const Renderer = {
    state: {
      viewMode: 'structured', // 'structured' or 'narrative'
      showProvenance: false,
      expandedGroups: new Set(),
      selectedCase: 'all',
      activeMainTab: 'client', // Main tab: client, cases, events, applications
      settingsOpen: false
    },

    init(data) {
      this.data = data;
      this.processedFields = DataProcessor.processFields(data);
      // Load user preferences
      FieldPreferences.load();
      // Organize fields by source table for tabs
      this.organizeFieldsByTab();
      this.render();
    },

    /**
     * Organize processed fields by their source table for tab display
     */
    organizeFieldsByTab() {
      const tabs = CONFIG?.MAIN_TABS || {};
      this.tabData = {};

      for (const [tabId, tabConfig] of Object.entries(tabs)) {
        const sourceTables = tabConfig.sourceTables || [];
        this.tabData[tabId] = {
          config: tabConfig,
          fields: this.processedFields.filter(f => {
            // Match by source table
            if (sourceTables.includes(f.sourceTable)) return true;
            // For client tab, include fields without sourceTable (from client info)
            if (tabId === 'client' && !f.sourceTable) return true;
            return false;
          }),
          allFieldNames: new Set()
        };

        // Collect all unique field names for settings
        this.tabData[tabId].fields.forEach(f => {
          this.tabData[tabId].allFieldNames.add(f.fieldName);
        });
      }
    },

    render() {
      const container = document.getElementById('app');

      const headerFields = DataProcessor.extractHeaderFields(this.processedFields);
      const clientName = headerFields.find(f => f.role === 'client_name')?.value || 'Unknown Client';

      // Get unique cases for the case filter (within Cases tab)
      const cases = [...new Set(this.processedFields.filter(f => f.caseLabel).map(f => f.caseLabel))];

      container.innerHTML = `
        <div class="widget-header">
          <span class="widget-title">Client At-a-Glance</span>
          <div class="view-toggle">
            <button class="${this.state.viewMode === 'structured' ? 'active' : ''}" data-view="structured">
              Structured
            </button>
            <button class="${this.state.viewMode === 'narrative' ? 'active' : ''}" data-view="narrative">
              Narrative
            </button>
          </div>
        </div>

        ${this.renderClientHeader(headerFields, clientName)}

        ${this.renderMainTabs()}

        ${this.renderTabContent(cases)}

        <div class="settings-row">
          <label class="settings-toggle">
            <input type="checkbox" ${this.state.showProvenance ? 'checked' : ''} data-setting="provenance">
            Show sources
          </label>
        </div>
      `;

      this.attachEventListeners();
    },

    renderClientHeader(headerFields, clientName) {
      const aNum = headerFields.find(f => f.role === 'a_number');
      const dob = headerFields.find(f => f.role === 'date_of_birth');
      const country = headerFields.find(f => f.role === 'country_of_origin');

      return `
        <div class="client-header">
          <div class="client-name">${Utils.escapeHtml(clientName)}</div>
          <div class="client-meta">
            ${aNum ? `<span class="client-meta-item"><span class="client-meta-label">A#</span> ${Utils.escapeHtml(aNum.value)}</span>` : ''}
            ${dob ? `<span class="client-meta-item"><span class="client-meta-label">DOB</span> ${Utils.escapeHtml(dob.rendered)}</span>` : ''}
            ${country ? `<span class="client-meta-item"><span class="client-meta-label">From</span> ${Utils.escapeHtml(country.value)}</span>` : ''}
          </div>
        </div>
      `;
    },

    /**
     * Render the main navigation tabs
     */
    renderMainTabs() {
      const tabs = CONFIG?.MAIN_TABS || {};

      return `
        <div class="main-tabs">
          ${Object.entries(tabs).map(([tabId, tabConfig]) => {
            const fieldCount = this.tabData[tabId]?.fields.length || 0;
            return `
              <button class="main-tab ${this.state.activeMainTab === tabId ? 'active' : ''}"
                      data-main-tab="${tabId}">
                ${tabConfig.label}
                <span class="tab-count">${fieldCount}</span>
              </button>
            `;
          }).join('')}
        </div>
      `;
    },

    /**
     * Render content for the active tab
     */
    renderTabContent(cases) {
      const activeTab = this.state.activeMainTab;
      const tabData = this.tabData[activeTab];

      if (!tabData || tabData.fields.length === 0) {
        return `<div class="no-data">No data available for this section.</div>`;
      }

      // Filter fields based on user preferences
      const visibleFieldNames = FieldPreferences.getVisibleFields(activeTab);
      let displayFields = tabData.fields;

      // If user has configured visible fields, filter by them
      if (visibleFieldNames.length > 0) {
        displayFields = tabData.fields.filter(f =>
          visibleFieldNames.includes(f.fieldName) &&
          !FieldPreferences.isAlwaysHidden(activeTab, f.fieldName)
        );
      } else {
        // Filter out always-hidden fields
        displayFields = tabData.fields.filter(f =>
          !FieldPreferences.isAlwaysHidden(activeTab, f.fieldName)
        );
      }

      // For Cases tab, show case filter
      const showCaseFilter = activeTab === 'cases' && cases.length > 1;
      if (showCaseFilter && this.state.selectedCase !== 'all') {
        displayFields = displayFields.filter(f =>
          !f.caseLabel || f.caseLabel === this.state.selectedCase
        );
      }

      return `
        ${this.renderSettingsPanel(activeTab, tabData)}

        ${showCaseFilter ? this.renderCaseTabs(cases) : ''}

        ${this.state.viewMode === 'narrative'
          ? this.renderNarrativeView(displayFields)
          : this.renderStructuredView(displayFields)}
      `;
    },

    /**
     * Render the field customization settings panel
     */
    renderSettingsPanel(tabId, tabData) {
      const allFieldNames = [...tabData.allFieldNames].sort();
      const visibleFields = FieldPreferences.getVisibleFields(tabId);
      const hasCustomization = visibleFields.length > 0;

      return `
        <div class="settings-panel ${this.state.settingsOpen ? 'open' : ''}">
          <div class="settings-panel-header" data-action="toggle-settings">
            <span class="settings-panel-title">
              Customize Fields ${hasCustomization ? `(${visibleFields.length} selected)` : ''}
            </span>
            <span>${this.state.settingsOpen ? '' : ''}</span>
          </div>
          <div class="settings-panel-content">
            <div class="field-checkbox-list">
              ${allFieldNames.map(fieldName => {
                const isAlwaysHidden = FieldPreferences.isAlwaysHidden(tabId, fieldName);
                if (isAlwaysHidden) return '';

                const isChecked = visibleFields.length === 0 || visibleFields.includes(fieldName);
                const schemaType = SchemaProcessor.getFieldType(fieldName);

                return `
                  <label class="field-checkbox-item">
                    <input type="checkbox"
                           data-field="${Utils.escapeHtml(fieldName)}"
                           data-tab="${tabId}"
                           ${isChecked ? 'checked' : ''}>
                    <span>${Utils.escapeHtml(fieldName)}</span>
                    ${schemaType ? `<span class="field-type">${schemaType}</span>` : ''}
                  </label>
                `;
              }).join('')}
            </div>
            <div class="settings-actions">
              <button class="settings-btn" data-action="select-all" data-tab="${tabId}">Select All</button>
              <button class="settings-btn" data-action="select-none" data-tab="${tabId}">Select None</button>
              <button class="settings-btn" data-action="reset-defaults" data-tab="${tabId}">Reset to Defaults</button>
            </div>
          </div>
        </div>
      `;
    },

    renderCaseTabs(cases) {
      return `
        <div class="case-tabs">
          <button class="case-tab ${this.state.selectedCase === 'all' ? 'active' : ''}" data-case="all">
            All Cases<span class="case-count">${cases.length}</span>
          </button>
          ${cases.map(c => `
            <button class="case-tab ${this.state.selectedCase === c ? 'active' : ''}" data-case="${Utils.escapeHtml(c)}">
              ${Utils.escapeHtml(c)}
            </button>
          `).join('')}
        </div>
      `;
    },

    renderNarrativeView(fields) {
      const narrative = DataProcessor.composeNarrative(fields);
      const tier2and3 = fields.filter(f => f.tier > 1);
      const grouped = DataProcessor.groupFields(tier2and3);

      return `
        <div class="narrative-view">
          <div class="narrative-text">
            ${narrative || '<em>No semantic data available for this section.</em>'}
          </div>
        </div>

        ${Object.keys(grouped).length > 0 ? `
          <div class="uncategorized-section">
            <button class="uncategorized-toggle" data-action="toggle-extra">
              <span></span>
              Additional fields (${tier2and3.length})
            </button>
            <div class="uncategorized-content" id="extra-fields">
              ${this.renderGroupedFields(grouped, true)}
            </div>
          </div>
        ` : ''}
      `;
    },

    renderStructuredView(fields) {
      // Exclude header fields from groups
      const headerRoles = CONFIG?.DISPLAY?.headerFields || [];
      const nonHeaderFields = fields.filter(f => !headerRoles.includes(f.role));
      const grouped = DataProcessor.groupFields(nonHeaderFields);

      if (Object.keys(grouped).length === 0) {
        return `<div class="no-data">No fields to display. Use the settings panel above to select fields.</div>`;
      }

      return `
        <div class="structured-view">
          ${this.renderGroupedFields(grouped, false)}
        </div>
      `;
    },

    renderGroupedFields(grouped, flat = false) {
      const groupOrder = CONFIG?.GROUP_ORDER || Object.keys(grouped);

      return groupOrder
        .filter(groupName => grouped[groupName] && grouped[groupName].length > 0)
        .map(groupName => {
          const groupFields = grouped[groupName];
          const isUncategorized = groupName === 'Uncategorized';
          const isExpanded = this.state.expandedGroups.has(groupName) || flat;

          if (flat) {
            return this.renderFlatGroup(groupName, groupFields);
          }

          return `
            <div class="field-group ${isExpanded ? '' : 'collapsed'}" data-group="${Utils.escapeHtml(groupName)}">
              <div class="field-group-header">
                <span class="field-group-title">
                  ${Utils.escapeHtml(groupName)}
                  <span class="field-group-count">(${groupFields.length})</span>
                </span>
                <span class="field-group-chevron"></span>
              </div>
              <div class="field-group-content">
                ${isUncategorized
                  ? this.renderTriplets(groupFields)
                  : this.renderFieldItems(groupFields)}
              </div>
            </div>
          `;
        }).join('');
    },

    renderFlatGroup(groupName, fields) {
      const isUncategorized = groupName === 'Uncategorized';

      return `
        <div style="margin-bottom: 16px;">
          <div style="font-weight: 500; font-size: 12px; color: var(--text-muted); margin-bottom: 8px; text-transform: uppercase;">
            ${Utils.escapeHtml(groupName)}
          </div>
          ${isUncategorized
            ? this.renderTriplets(fields)
            : this.renderFieldItems(fields)}
        </div>
      `;
    },

    renderFieldItems(fields) {
      return fields.map(field => {
        // Use displayLabel from schema processing, or fall back to humanized field name
        const label = field.displayLabel || Utils.humanizeFieldName(field.fieldName);

        return `
          <div class="field-item">
            <span class="field-label">
              <span class="tier-indicator tier-${field.tier}" title="Tier ${field.tier}${field.schemaType ? ' | ' + field.schemaType : ''}"></span>
              ${Utils.escapeHtml(label)}
            </span>
            <span class="field-value">
              ${this.renderFieldValue(field)}
              ${this.state.showProvenance && field.caseLabel
                ? `<span class="provenance-badge">${Utils.escapeHtml(field.caseLabel)}</span>`
                : ''}
            </span>
          </div>
        `;
      }).join('');
    },

    renderFieldValue(field) {
      // Handle button fields
      if (field.dataType === 'button' && field.buttonUrl) {
        return `<a href="${Utils.escapeHtml(field.buttonUrl)}" target="_blank" rel="noopener" class="button-link">${Utils.escapeHtml(field.buttonLabel || 'Open')} </a>`;
      }

      // Handle attachment fields
      if (field.dataType === 'attachment' && field.buttonUrl) {
        const icon = field.fileType?.includes('pdf') ? '' : '';
        return `<a href="${Utils.escapeHtml(field.buttonUrl)}" target="_blank" rel="noopener" class="button-link">${icon} ${Utils.escapeHtml(field.buttonLabel || 'Download')}</a>`;
      }

      const value = field.rendered || field.value;

      // Check if it's a URL
      if (field.dataType === 'url' || /^https?:\/\//.test(String(value))) {
        return `<a href="${Utils.escapeHtml(value)}" target="_blank" rel="noopener">Link </a>`;
      }

      // Truncate long values
      const strValue = String(value);
      if (strValue.length > 100) {
        return `<span title="${Utils.escapeHtml(strValue)}">${Utils.escapeHtml(strValue.slice(0, 100))}</span>`;
      }

      return Utils.escapeHtml(strValue);
    },

    renderTriplets(fields) {
      return fields.map(field => `
        <div class="triplet">
          <span class="triplet-source">[${Utils.escapeHtml(field.caseLabel || field.sourceTable)}]</span>
          <span class="triplet-field">${Utils.escapeHtml(field.fieldName)}</span>
          <span class="triplet-value">${this.renderFieldValue(field)}</span>
        </div>
      `).join('');
    },

    attachEventListeners() {
      // View toggle
      document.querySelectorAll('.view-toggle button').forEach(btn => {
        btn.addEventListener('click', (e) => {
          this.state.viewMode = e.target.dataset.view;
          this.render();
        });
      });

      // Main tabs
      document.querySelectorAll('.main-tab').forEach(btn => {
        btn.addEventListener('click', (e) => {
          this.state.activeMainTab = e.target.dataset.mainTab;
          this.state.settingsOpen = false; // Close settings when switching tabs
          this.render();
        });
      });

      // Case tabs (within Cases tab)
      document.querySelectorAll('.case-tab').forEach(btn => {
        btn.addEventListener('click', (e) => {
          this.state.selectedCase = e.target.dataset.case;
          this.render();
        });
      });

      // Settings panel toggle
      const settingsToggle = document.querySelector('[data-action="toggle-settings"]');
      if (settingsToggle) {
        settingsToggle.addEventListener('click', () => {
          this.state.settingsOpen = !this.state.settingsOpen;
          this.render();
        });
      }

      // Field checkboxes
      document.querySelectorAll('.field-checkbox-item input').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
          const fieldName = e.target.dataset.field;
          const tabId = e.target.dataset.tab;
          const checked = e.target.checked;

          // Get current visible fields
          const currentVisible = FieldPreferences.getVisibleFields(tabId);

          // If no customization yet, start with all fields
          if (currentVisible.length === 0) {
            const allFields = [...this.tabData[tabId].allFieldNames].filter(
              f => !FieldPreferences.isAlwaysHidden(tabId, f)
            );
            if (checked) {
              // Already showing all, nothing to do
            } else {
              // Remove this field from all
              const newVisible = allFields.filter(f => f !== fieldName);
              FieldPreferences.setVisibleFields(tabId, newVisible);
            }
          } else {
            // Toggle the field
            FieldPreferences.toggleField(tabId, fieldName, checked);
          }

          this.render();
        });
      });

      // Select All button
      document.querySelectorAll('[data-action="select-all"]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const tabId = e.target.dataset.tab;
          const allFields = [...this.tabData[tabId].allFieldNames].filter(
            f => !FieldPreferences.isAlwaysHidden(tabId, f)
          );
          FieldPreferences.setVisibleFields(tabId, allFields);
          this.render();
        });
      });

      // Select None button
      document.querySelectorAll('[data-action="select-none"]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const tabId = e.target.dataset.tab;
          FieldPreferences.setVisibleFields(tabId, []);
          this.render();
        });
      });

      // Reset to Defaults button
      document.querySelectorAll('[data-action="reset-defaults"]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const tabId = e.target.dataset.tab;
          const defaults = CONFIG?.MAIN_TABS?.[tabId]?.defaultFields || [];
          FieldPreferences.setVisibleFields(tabId, defaults);
          this.render();
        });
      });

      // Group expand/collapse
      document.querySelectorAll('.field-group-header').forEach(header => {
        header.addEventListener('click', (e) => {
          const group = e.currentTarget.parentElement;
          const groupName = group.dataset.group;

          if (this.state.expandedGroups.has(groupName)) {
            this.state.expandedGroups.delete(groupName);
          } else {
            this.state.expandedGroups.add(groupName);
          }

          group.classList.toggle('collapsed');
        });
      });

      // Extra fields toggle
      const extraToggle = document.querySelector('[data-action="toggle-extra"]');
      if (extraToggle) {
        extraToggle.addEventListener('click', () => {
          const content = document.getElementById('extra-fields');
          content.classList.toggle('visible');
          extraToggle.querySelector('span').textContent = content.classList.contains('visible') ? '' : '';
        });
      }

      // Settings toggles (provenance)
      document.querySelectorAll('[data-setting]').forEach(input => {
        input.addEventListener('change', (e) => {
          if (e.target.dataset.setting === 'provenance') {
            this.state.showProvenance = e.target.checked;
            this.render();
          }
        });
      });
    }
  };

  // ==========================================================================
  // DATA FETCHER
  // ==========================================================================

  const DataFetcher = {
    async fetchClientData(recordId) {
      // For development/demo, check for mock data
      if (window.MOCK_DATA) {
        // Initialize schema if provided separately
        if (window.MOCK_SCHEMA && !SchemaProcessor.hasSchema()) {
          SchemaProcessor.init(window.MOCK_SCHEMA);
        }
        return window.MOCK_DATA;
      }

      const url = `${WEBHOOK_URL}?recordId=${encodeURIComponent(recordId)}`;
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Accept': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return response.json();
    }
  };

  // ==========================================================================
  // INITIALIZATION
  // ==========================================================================

  async function init() {
    const container = document.getElementById('app');

    try {
      // Check for config
      if (!CONFIG) {
        throw new Error('Configuration not loaded. Make sure config.js is included.');
      }

      // Initialize schema if provided globally (for testing/development)
      if (window.MOCK_SCHEMA && !SchemaProcessor.hasSchema()) {
        console.log('[init] Initializing schema from MOCK_SCHEMA');
        SchemaProcessor.init(window.MOCK_SCHEMA);
      }

      // Get record ID - wait briefly for postMessage if in iframe context
      let recordId = Utils.getRecordId();

      // If no recordId and we might be in an iframe, wait briefly for postMessage
      if (!recordId && !window.MOCK_DATA && window.parent !== window) {
        console.log('[init] No recordId found, waiting for postMessage...');
        container.innerHTML = `<div class="loading"><div>Waiting for data...</div></div>`;

        // Wait up to 500ms for postMessage
        await new Promise(resolve => {
          const checkInterval = setInterval(() => {
            if (postMessageRecordId) {
              clearInterval(checkInterval);
              resolve();
            }
          }, 50);
          setTimeout(() => {
            clearInterval(checkInterval);
            resolve();
          }, 500);
        });

        recordId = Utils.getRecordId();
      }

      if (!recordId && !window.MOCK_DATA) {
        container.innerHTML = `
          <div class="error">
            <div class="error-title">No Record ID</div>
            <div>Please provide a recordId parameter in the URL.</div>
          </div>
        `;
        return;
      }

      // Show loading state
      container.innerHTML = `
        <div class="loading">
          <div>Loading client data...</div>
          ${SchemaProcessor.hasSchema() ? '<div class="loading-detail">Schema loaded</div>' : ''}
        </div>
      `;

      // Fetch data
      const data = await DataFetcher.fetchClientData(recordId);

      // Log schema status
      console.log('[init] Schema status:', SchemaProcessor.hasSchema() ? 'loaded' : 'not loaded');

      // Initialize renderer
      Renderer.init(data);

    } catch (error) {
      console.error('Client Glance Error:', error);
      container.innerHTML = `
        <div class="error">
          <div class="error-title">Error Loading Data</div>
          <div>${Utils.escapeHtml(error.message)}</div>
        </div>
      `;
    }
  }

  // Auto-expand first few groups
  Renderer.state.expandedGroups.add('Court');
  Renderer.state.expandedGroups.add('SIJ');
  Renderer.state.expandedGroups.add('USCIS');

  // Initialize when DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  // Expose for debugging
  window.ClientGlance = { Utils, DataProcessor, Renderer, DataFetcher, SchemaProcessor, DataTransformer };

})();
</script>

</body>
</html>
