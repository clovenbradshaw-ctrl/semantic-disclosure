<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Client At-a-Glance</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-primary: #fafaf9;
      --bg-secondary: #f5f5f4;
      --bg-tertiary: #e7e5e4;
      --bg-card: #ffffff;
      --text-primary: #1c1917;
      --text-secondary: #57534e;
      --text-muted: #a8a29e;
      --border: #e7e5e4;
      --border-strong: #d6d3d1;
      --accent-blue: #0369a1;
      --accent-green: #15803d;
      --accent-amber: #b45309;
      --accent-rose: #be123c;
      --accent-violet: #7c3aed;
      --accent-slate: #475569;
      --shadow-sm: 0 1px 2px rgba(28, 25, 23, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(28, 25, 23, 0.07);
      --radius: 6px;
      --font-sans: 'IBM Plex Sans', -apple-system, sans-serif;
      --font-mono: 'IBM Plex Mono', monospace;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: var(--font-sans);
      background: var(--bg-primary);
      color: var(--text-primary);
      font-size: 14px;
      line-height: 1.5;
      padding: 16px;
    }

    .widget-container {
      max-width: 800px;
      margin: 0 auto;
    }

    /* Header Controls */
    .widget-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }

    .widget-title {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .view-toggle {
      display: flex;
      gap: 4px;
      background: var(--bg-secondary);
      padding: 3px;
      border-radius: var(--radius);
    }

    .view-toggle button {
      padding: 6px 12px;
      border: none;
      background: transparent;
      font-family: var(--font-sans);
      font-size: 13px;
      color: var(--text-secondary);
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.15s ease;
    }

    .view-toggle button.active {
      background: var(--bg-card);
      color: var(--text-primary);
      box-shadow: var(--shadow-sm);
    }

    .view-toggle button:hover:not(.active) {
      color: var(--text-primary);
    }

    /* Client Header Card */
    .client-header {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px 20px;
      margin-bottom: 16px;
      box-shadow: var(--shadow-sm);
    }

    .client-name {
      font-size: 20px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 4px;
    }

    .client-meta {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      color: var(--text-secondary);
      font-size: 14px;
    }

    .client-meta-item {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .client-meta-label {
      color: var(--text-muted);
      font-size: 12px;
    }

    /* Matter Pills */
    .matter-pills {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 10px;
    }

    .matter-pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
      border: 2px solid transparent;
    }

    .matter-pill.active {
      border-color: currentColor;
    }

    .matter-pill:hover {
      opacity: 0.8;
    }

    .matter-pill .matter-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: currentColor;
    }

    .matter-pill.asylum { background: #dbeafe; color: #1e40af; }
    .matter-pill.sij { background: #dcfce7; color: #166534; }
    .matter-pill.uvisa { background: #ede9fe; color: #5b21b6; }
    .matter-pill.bond { background: #fef3c7; color: #92400e; }
    .matter-pill.family { background: #ffe4e6; color: #9f1239; }
    .matter-pill.removal { background: #fee2e2; color: #dc2626; }

    /* Narrative View */
    .narrative-view {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 20px 24px;
      margin-bottom: 16px;
      box-shadow: var(--shadow-sm);
    }

    .narrative-text {
      font-size: 15px;
      line-height: 1.7;
      color: var(--text-primary);
    }

    .narrative-text .provenance {
      font-size: 11px;
      color: var(--text-muted);
      vertical-align: super;
      margin-left: 2px;
      cursor: help;
    }

    /* Structured View */
    .structured-view {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .field-group {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
      box-shadow: var(--shadow-sm);
    }

    .field-group-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      user-select: none;
      transition: background 0.15s ease;
    }

    .field-group-header:hover {
      background: var(--bg-tertiary);
    }

    .field-group-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-weight: 500;
      font-size: 13px;
      color: var(--text-primary);
    }

    .field-group-count {
      font-size: 12px;
      color: var(--text-muted);
      font-weight: 400;
    }

    .field-group-chevron {
      color: var(--text-muted);
      transition: transform 0.2s ease;
      font-size: 12px;
    }

    .field-group.collapsed .field-group-chevron {
      transform: rotate(-90deg);
    }

    .field-group.collapsed .field-group-content {
      display: none;
    }

    .field-group-content {
      padding: 12px 16px;
    }

    /* Field Items */
    .field-item {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      padding: 8px 0;
      border-bottom: 1px solid var(--bg-secondary);
    }

    .field-item:last-child {
      border-bottom: none;
    }

    .field-label {
      font-size: 13px;
      color: var(--text-secondary);
      flex-shrink: 0;
      max-width: 45%;
    }

    .field-value {
      font-size: 13px;
      color: var(--text-primary);
      text-align: right;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .field-value a {
      color: var(--accent-blue);
      text-decoration: none;
    }

    .field-value a:hover {
      text-decoration: underline;
    }

    .field-value a.button-link {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 4px 10px;
      background: var(--bg-secondary);
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
      transition: background 0.15s ease;
    }

    .field-value a.button-link:hover {
      background: var(--bg-tertiary);
      text-decoration: none;
    }

    /* Provenance Badge */
    .provenance-badge {
      font-size: 10px;
      font-family: var(--font-mono);
      padding: 2px 6px;
      background: var(--bg-secondary);
      border-radius: 3px;
      color: var(--text-muted);
      white-space: nowrap;
    }

    /* Tier Indicators */
    .tier-indicator {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      flex-shrink: 0;
    }

    .tier-1 { background: var(--accent-green); }
    .tier-2 { background: var(--accent-blue); }
    .tier-3 { background: var(--accent-amber); }

    /* Uncategorized Section */
    .uncategorized-section {
      margin-top: 8px;
    }

    .uncategorized-toggle {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 14px;
      background: var(--bg-secondary);
      border: 1px dashed var(--border-strong);
      border-radius: var(--radius);
      cursor: pointer;
      font-size: 13px;
      color: var(--text-secondary);
      width: 100%;
      transition: all 0.15s ease;
    }

    .uncategorized-toggle:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .uncategorized-content {
      display: none;
      margin-top: 8px;
      padding: 12px 16px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
    }

    .uncategorized-content.visible {
      display: block;
    }

    /* Raw Triplet Display */
    .triplet {
      display: grid;
      grid-template-columns: auto 1fr auto;
      gap: 8px;
      padding: 6px 0;
      font-family: var(--font-mono);
      font-size: 12px;
      border-bottom: 1px solid var(--bg-secondary);
      align-items: center;
    }

    .triplet:last-child {
      border-bottom: none;
    }

    .triplet-source {
      color: var(--text-muted);
      font-size: 11px;
    }

    .triplet-field {
      color: var(--accent-violet);
    }

    .triplet-arrow {
      color: var(--text-muted);
    }

    .triplet-value {
      color: var(--text-primary);
      text-align: right;
      word-break: break-word;
    }

    /* Case Tabs */
    .case-tabs-container {
      margin-bottom: 16px;
    }

    .case-tabs-header {
      margin-bottom: 8px;
    }

    .case-tabs-label {
      font-size: 11px;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .case-tabs {
      display: flex;
      gap: 4px;
      padding: 4px;
      background: var(--bg-secondary);
      border-radius: var(--radius);
      overflow-x: auto;
    }

    .case-tab {
      padding: 8px 14px;
      border: none;
      background: transparent;
      font-family: var(--font-sans);
      font-size: 13px;
      color: var(--text-secondary);
      cursor: pointer;
      border-radius: 4px;
      white-space: nowrap;
      transition: all 0.15s ease;
    }

    .case-tab.active {
      background: var(--bg-card);
      color: var(--text-primary);
      box-shadow: var(--shadow-sm);
    }

    .case-tab:hover:not(.active) {
      color: var(--text-primary);
    }

    .case-tab .case-count {
      font-size: 11px;
      color: var(--text-muted);
      margin-left: 6px;
    }

    /* Loading State */
    .loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 48px;
      color: var(--text-secondary);
    }

    .loading-spinner {
      width: 24px;
      height: 24px;
      border: 2px solid var(--border);
      border-top-color: var(--accent-blue);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-bottom: 12px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-detail {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 8px;
    }

    /* Error State */
    .error {
      padding: 24px;
      background: #fef2f2;
      border: 1px solid #fecaca;
      border-radius: var(--radius);
      color: #991b1b;
    }

    .error-title {
      font-weight: 600;
      margin-bottom: 4px;
    }

    /* Provenance Tooltip */
    .provenance-tooltip {
      position: absolute;
      background: var(--text-primary);
      color: white;
      padding: 8px 12px;
      border-radius: var(--radius);
      font-size: 12px;
      max-width: 250px;
      z-index: 1000;
      box-shadow: var(--shadow-md);
      pointer-events: none;
    }

    .provenance-tooltip::before {
      content: '';
      position: absolute;
      top: -6px;
      left: 50%;
      transform: translateX(-50%);
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-bottom: 6px solid var(--text-primary);
    }

    /* Settings Toggle */
    .settings-row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }

    .settings-toggle {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: var(--text-muted);
      cursor: pointer;
    }

    .settings-toggle input {
      cursor: pointer;
    }

    /* Empty State */
    .empty-state {
      padding: 32px;
      text-align: center;
      color: var(--text-muted);
    }

    /* Main Tabs - Top-level navigation */
    .main-tabs {
      display: flex;
      gap: 2px;
      margin-bottom: 16px;
      border-bottom: 2px solid var(--border);
    }

    .main-tab {
      padding: 10px 18px;
      border: none;
      background: transparent;
      font-family: var(--font-sans);
      font-size: 14px;
      font-weight: 500;
      color: var(--text-secondary);
      cursor: pointer;
      position: relative;
      transition: color 0.15s ease;
    }

    .main-tab:hover {
      color: var(--text-primary);
    }

    .main-tab.active {
      color: var(--accent-blue);
    }

    .main-tab.active::after {
      content: '';
      position: absolute;
      bottom: -2px;
      left: 0;
      right: 0;
      height: 2px;
      background: var(--accent-blue);
    }

    .main-tab .tab-count {
      font-size: 11px;
      color: var(--text-muted);
      margin-left: 4px;
      font-weight: 400;
    }

    /* Tab Content */
    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    /* Settings Panel */
    .settings-panel {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      margin-bottom: 16px;
      overflow: hidden;
    }

    .settings-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: var(--bg-secondary);
      cursor: pointer;
      user-select: none;
    }

    .settings-panel-header:hover {
      background: var(--bg-tertiary);
    }

    .settings-panel-title {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-secondary);
    }

    .settings-panel-content {
      display: none;
      padding: 16px;
      border-top: 1px solid var(--border);
    }

    .settings-panel.open .settings-panel-content {
      display: block;
    }

    .field-checkbox-list {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 8px;
      max-height: 300px;
      overflow-y: auto;
    }

    .field-checkbox-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      background: var(--bg-secondary);
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
      transition: background 0.15s ease;
    }

    .field-checkbox-item:hover {
      background: var(--bg-tertiary);
    }

    .field-checkbox-item input {
      cursor: pointer;
    }

    .field-checkbox-item .field-type {
      font-size: 10px;
      color: var(--text-muted);
      margin-left: auto;
    }

    .settings-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid var(--border);
    }

    .settings-btn {
      padding: 6px 12px;
      font-size: 12px;
      font-family: var(--font-sans);
      border: 1px solid var(--border);
      background: var(--bg-card);
      color: var(--text-secondary);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .settings-btn:hover {
      background: var(--bg-secondary);
      color: var(--text-primary);
    }

    .settings-btn.primary {
      background: var(--accent-blue);
      border-color: var(--accent-blue);
      color: white;
    }

    .settings-btn.primary:hover {
      background: #0284c7;
    }

    /* No Data State */
    .no-data {
      padding: 24px;
      text-align: center;
      color: var(--text-muted);
      font-size: 13px;
    }

    /* Semantic Tuple Card */
    .tuple-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      margin-bottom: 12px;
      overflow: hidden;
    }

    .tuple-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
    }

    .tuple-card-title {
      font-weight: 500;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .tuple-card-status {
      font-size: 12px;
      padding: 3px 10px;
      border-radius: 10px;
      font-weight: 500;
    }

    .tuple-card-content {
      padding: 12px 16px;
    }

    .tuple-field-row {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid var(--bg-secondary);
    }

    .tuple-field-row:last-child {
      border-bottom: none;
    }

    .tuple-field-label {
      color: var(--text-secondary);
      font-size: 13px;
    }

    .tuple-field-value {
      font-size: 13px;
      text-align: right;
    }

    /* Overview Cards */
    .overview-section {
      margin-bottom: 20px;
    }

    .overview-section-title {
      font-size: 12px;
      font-weight: 500;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
    }

    .matter-cards {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
      gap: 12px;
    }

    .matter-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 14px 16px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .matter-card:hover {
      border-color: var(--border-strong);
      box-shadow: var(--shadow-md);
    }

    .matter-card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 8px;
    }

    .matter-card-type {
      font-weight: 600;
      font-size: 14px;
    }

    .matter-card-status {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 8px;
    }

    .matter-card-details {
      font-size: 13px;
      color: var(--text-secondary);
    }

    .matter-card-detail {
      margin-bottom: 4px;
    }

    /* Upcoming Events Section */
    .upcoming-events {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
    }

    .upcoming-event {
      display: flex;
      align-items: flex-start;
      gap: 12px;
      padding: 12px 16px;
      border-bottom: 1px solid var(--bg-secondary);
    }

    .upcoming-event:last-child {
      border-bottom: none;
    }

    .event-urgency {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-top: 6px;
      flex-shrink: 0;
    }

    .event-urgency.urgent { background: #dc2626; }
    .event-urgency.upcoming { background: #f59e0b; }
    .event-urgency.scheduled { background: #22c55e; }
    .event-urgency.past { background: #9ca3af; }

    .event-content {
      flex: 1;
    }

    .event-date {
      font-weight: 500;
      font-size: 13px;
    }

    .event-title {
      font-size: 13px;
      color: var(--text-secondary);
    }

    .event-meta {
      font-size: 12px;
      color: var(--text-muted);
    }

    .event-matter-tag {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 500;
    }

    /* Notes Feed */
    .notes-feed {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .note-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
    }

    .note-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 14px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
    }

    .note-matter-tag {
      font-size: 11px;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 4px;
    }

    .note-date {
      font-size: 12px;
      color: var(--text-muted);
    }

    .note-content {
      padding: 12px 14px;
      font-size: 13px;
      line-height: 1.6;
      white-space: pre-wrap;
    }

    .note-content.truncated {
      max-height: 100px;
      overflow: hidden;
      position: relative;
    }

    .note-content.truncated::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 40px;
      background: linear-gradient(transparent, var(--bg-card));
    }

    .note-expand-btn {
      padding: 8px 14px;
      font-size: 12px;
      color: var(--accent-blue);
      cursor: pointer;
      border-top: 1px solid var(--bg-secondary);
    }

    .note-expand-btn:hover {
      background: var(--bg-secondary);
    }

    /* Narrative Toggle */
    .narrative-toggle {
      display: flex;
      gap: 4px;
      background: var(--bg-secondary);
      padding: 2px;
      border-radius: 4px;
      margin-bottom: 12px;
    }

    .narrative-toggle button {
      padding: 4px 10px;
      border: none;
      background: transparent;
      font-family: var(--font-sans);
      font-size: 12px;
      color: var(--text-secondary);
      cursor: pointer;
      border-radius: 3px;
      transition: all 0.15s ease;
    }

    .narrative-toggle button.active {
      background: var(--bg-card);
      color: var(--text-primary);
      box-shadow: var(--shadow-sm);
    }

    /* Status Colors */
    .status-green { background: #dcfce7; color: #166534; }
    .status-blue { background: #dbeafe; color: #1e40af; }
    .status-yellow { background: #fef3c7; color: #92400e; }
    .status-red { background: #fee2e2; color: #dc2626; }
    .status-gray { background: #f3f4f6; color: #4b5563; }

    /* Timeline View */
    .timeline-view {
      position: relative;
      padding-left: 24px;
    }

    .timeline-view::before {
      content: '';
      position: absolute;
      left: 7px;
      top: 0;
      bottom: 0;
      width: 2px;
      background: var(--border);
    }

    .timeline-item {
      position: relative;
      padding-bottom: 20px;
    }

    .timeline-item::before {
      content: '';
      position: absolute;
      left: -20px;
      top: 4px;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: var(--bg-card);
      border: 2px solid var(--accent-blue);
    }

    .timeline-item.future::before {
      background: var(--accent-blue);
    }

    .timeline-date {
      font-size: 12px;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .timeline-content {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 10px 14px;
    }

    .timeline-title {
      font-weight: 500;
      font-size: 13px;
      margin-bottom: 4px;
    }

    .timeline-detail {
      font-size: 12px;
      color: var(--text-secondary);
    }

    /* Timeline Grouping */
    .timeline-grouped {
      padding-left: 0;
    }

    .timeline-grouped::before {
      display: none;
    }

    .timeline-group {
      margin-bottom: 20px;
      padding-left: 24px;
      position: relative;
    }

    .timeline-group::before {
      content: '';
      position: absolute;
      left: 8px;
      top: 24px;
      bottom: 0;
      width: 2px;
      background: var(--border);
    }

    .timeline-group-header {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 10px;
      padding: 4px 0;
    }

    .timeline-meta {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 4px;
    }

    .timeline-group-tag {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 500;
    }

    .timeline-item[data-urgency="urgent"] .timeline-content {
      border-left: 3px solid #dc2626;
    }

    .timeline-item[data-urgency="upcoming"] .timeline-content {
      border-left: 3px solid #f59e0b;
    }

    .timeline-item[data-urgency="scheduled"] .timeline-content {
      border-left: 3px solid #10b981;
    }

    /* Google Calendar Event Styles */
    .timeline-item.calendar-event .timeline-content {
      background: linear-gradient(135deg, #f8faff 0%, #ffffff 100%);
      border-color: #4285f420;
    }

    .timeline-item.calendar-event::before {
      border-color: #4285f4;
      background: #4285f4;
    }

    .timeline-item.calendar-event.future::before {
      background: #4285f4;
      box-shadow: 0 0 0 3px #4285f420;
    }

    .calendar-icon {
      font-size: 12px;
    }

    .calendar-link {
      color: #4285f4;
      text-decoration: none;
      font-size: 11px;
      margin-left: 4px;
      opacity: 0.7;
      transition: opacity 0.15s;
    }

    .calendar-link:hover {
      opacity: 1;
    }

    .timeline-location {
      font-size: 12px;
      color: var(--text-secondary);
      margin-top: 4px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .location-icon {
      font-size: 11px;
    }

    .timeline-description {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 6px;
      padding: 6px 8px;
      background: var(--bg-secondary);
      border-radius: 4px;
      line-height: 1.4;
    }

    .timeline-attendees {
      font-size: 11px;
      color: var(--text-secondary);
      margin-top: 4px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .attendees-icon {
      font-size: 10px;
    }

    .timeline-date-end {
      color: var(--text-muted);
      font-size: 11px;
    }

    /* Calendar group header styling */
    .timeline-group-header[style*="#4285f4"] {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .timeline-group-header[style*="#4285f4"]::before {
      content: 'üìÖ';
      font-size: 12px;
    }

    /* Events View - Google Calendar Events Display */
    .events-view {
      padding: 0;
    }

    .events-section {
      margin-bottom: 24px;
    }

    .events-section-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 0;
      margin-bottom: 12px;
      border-bottom: 2px solid currentColor;
    }

    .events-section-icon {
      font-size: 14px;
    }

    .events-section-title {
      font-size: 12px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .events-section-count {
      background: currentColor;
      color: white;
      font-size: 11px;
      font-weight: 600;
      padding: 2px 8px;
      border-radius: 10px;
      margin-left: auto;
    }

    .events-section-count::before {
      content: '';
      background: white;
      border-radius: 50%;
    }

    .events-section-divider {
      height: 1px;
      background: var(--border);
      margin: 20px 0;
    }

    .events-list {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .event-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 16px;
      transition: box-shadow 0.15s ease;
    }

    .event-card:hover {
      box-shadow: var(--shadow-md);
    }

    .event-card.urgent {
      border-left: 4px solid #dc2626;
      background: linear-gradient(135deg, #fef2f2 0%, #ffffff 100%);
    }

    .event-card.upcoming {
      border-left: 4px solid #f59e0b;
      background: linear-gradient(135deg, #fffbeb 0%, #ffffff 100%);
    }

    .event-card.scheduled {
      border-left: 4px solid #10b981;
      background: linear-gradient(135deg, #ecfdf5 0%, #ffffff 100%);
    }

    .event-card.past {
      border-left: 4px solid #6b7280;
      opacity: 0.8;
    }

    .event-card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 8px;
    }

    .event-card-date {
      font-size: 12px;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .event-date-primary {
      color: var(--text-primary);
    }

    .event-date-end {
      color: var(--text-muted);
    }

    .event-calendar-link {
      font-size: 11px;
      color: #4285f4;
      text-decoration: none;
      padding: 4px 8px;
      background: #4285f410;
      border-radius: 4px;
      transition: background 0.15s;
    }

    .event-calendar-link:hover {
      background: #4285f420;
    }

    .event-card-title {
      font-size: 15px;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 8px;
      line-height: 1.3;
    }

    .event-card-location {
      font-size: 13px;
      color: var(--text-secondary);
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .event-location-icon {
      font-size: 12px;
    }

    .event-card-description {
      font-size: 12px;
      color: var(--text-muted);
      padding: 8px 10px;
      background: var(--bg-secondary);
      border-radius: 4px;
      line-height: 1.5;
      margin-bottom: 8px;
    }

    .event-card-attendees {
      font-size: 12px;
      color: var(--text-secondary);
      margin-bottom: 6px;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .event-attendees-icon {
      font-size: 11px;
    }

    .event-card-organizer {
      font-size: 11px;
      color: var(--text-muted);
      margin-bottom: 8px;
    }

    .event-organizer-label {
      color: var(--text-secondary);
      font-weight: 500;
    }

    .event-card-footer {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--border);
    }

    .event-type-tag {
      font-size: 10px;
      padding: 3px 8px;
      background: var(--bg-tertiary);
      color: var(--text-secondary);
      border-radius: 4px;
      font-weight: 500;
    }

    .event-source-tag {
      font-size: 10px;
      padding: 3px 8px;
      border-radius: 4px;
      font-weight: 500;
    }

    .event-source-tag.google {
      background: #4285f410;
      color: #4285f4;
    }

    /* No events message */
    .no-events-message {
      text-align: center;
      padding: 48px 24px;
      color: var(--text-muted);
    }

    .no-events-icon {
      font-size: 48px;
      margin-bottom: 16px;
      opacity: 0.5;
    }

    .no-events-title {
      font-size: 18px;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 8px;
    }

    .no-events-text {
      font-size: 13px;
      line-height: 1.6;
    }

    .no-events-text code {
      font-family: var(--font-mono);
      font-size: 11px;
      background: var(--bg-tertiary);
      padding: 2px 6px;
      border-radius: 3px;
    }

    /* Application Cards */
    .application-cards {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      gap: 12px;
    }

    .application-card {
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      padding: 14px;
    }

    .application-card-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 10px;
    }

    .application-type {
      font-weight: 600;
      font-size: 15px;
    }

    .application-name {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .application-status {
      font-size: 11px;
      padding: 2px 8px;
      border-radius: 8px;
    }

    .application-details {
      font-size: 12px;
    }

    .application-detail {
      display: flex;
      justify-content: space-between;
      padding: 4px 0;
      border-bottom: 1px solid var(--bg-secondary);
    }

    .application-detail:last-child {
      border-bottom: none;
    }

    .application-detail-label {
      color: var(--text-muted);
    }

    /* Responsive */
    @media (max-width: 600px) {
      body {
        padding: 12px;
      }

      .field-item {
        flex-direction: column;
        gap: 4px;
      }

      .field-label {
        max-width: 100%;
      }

      .field-value {
        text-align: left;
      }

      .client-meta {
        flex-direction: column;
        gap: 8px;
      }

      .main-tabs {
        overflow-x: auto;
      }

      .main-tab {
        padding: 8px 12px;
        font-size: 13px;
        white-space: nowrap;
      }

      .field-checkbox-list {
        grid-template-columns: 1fr;
      }
    }

    /* =========================================================================
       FIELD CANVAS - Visual Field Configuration System
       ========================================================================= */

    /* Modal Overlay */
    .field-canvas-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
    }

    .field-canvas-overlay.visible {
      opacity: 1;
      visibility: visible;
    }

    .field-canvas-modal {
      background: var(--bg-card);
      border-radius: 8px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
      width: 100%;
      max-width: 900px;
      max-height: 90vh;
      display: flex;
      flex-direction: column;
      transform: scale(0.95);
      transition: transform 0.2s ease;
    }

    .field-canvas-overlay.visible .field-canvas-modal {
      transform: scale(1);
    }

    /* Modal Header */
    .field-canvas-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    .field-canvas-title {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .field-canvas-title h2 {
      font-size: 16px;
      font-weight: 600;
      margin: 0;
    }

    .field-canvas-title .tab-context {
      font-size: 12px;
      color: var(--text-muted);
      padding: 3px 10px;
      background: var(--bg-secondary);
      border-radius: 12px;
    }

    .field-canvas-close {
      width: 32px;
      height: 32px;
      border: none;
      background: var(--bg-secondary);
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      color: var(--text-secondary);
      transition: all 0.15s ease;
    }

    .field-canvas-close:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    /* View Tabs */
    .field-canvas-tabs {
      display: flex;
      gap: 4px;
      padding: 12px 20px;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
    }

    .field-canvas-tab {
      padding: 8px 16px;
      border: none;
      background: transparent;
      font-family: var(--font-sans);
      font-size: 13px;
      color: var(--text-secondary);
      cursor: pointer;
      border-radius: 6px;
      transition: all 0.15s ease;
    }

    .field-canvas-tab:hover {
      color: var(--text-primary);
    }

    .field-canvas-tab.active {
      background: var(--bg-card);
      color: var(--text-primary);
      box-shadow: var(--shadow-sm);
    }

    /* Modal Content */
    .field-canvas-content {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    .field-canvas-view {
      display: none;
      flex: 1;
      overflow: hidden;
    }

    .field-canvas-view.active {
      display: flex;
      flex-direction: column;
    }

    /* Search & Filter Bar */
    .field-canvas-toolbar {
      display: flex;
      gap: 12px;
      padding: 12px 20px;
      border-bottom: 1px solid var(--border);
      flex-shrink: 0;
      flex-wrap: wrap;
    }

    .field-canvas-search {
      flex: 1;
      min-width: 200px;
      position: relative;
    }

    .field-canvas-search input {
      width: 100%;
      padding: 8px 12px 8px 32px;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-family: var(--font-sans);
      font-size: 13px;
      background: var(--bg-secondary);
      transition: all 0.15s ease;
    }

    .field-canvas-search input:focus {
      outline: none;
      border-color: var(--accent-blue);
      background: var(--bg-card);
    }

    .field-canvas-search::before {
      content: 'üîç';
      position: absolute;
      left: 10px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 12px;
      opacity: 0.5;
    }

    .field-canvas-filter {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .field-canvas-filter select {
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 6px;
      font-family: var(--font-sans);
      font-size: 13px;
      background: var(--bg-secondary);
      cursor: pointer;
    }

    .field-canvas-filter select:focus {
      outline: none;
      border-color: var(--accent-blue);
    }

    /* Data Atlas View - All Fields Overview */
    .data-atlas-container {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .data-atlas-table-group {
      margin-bottom: 24px;
    }

    .data-atlas-table-header {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 14px;
      background: var(--bg-secondary);
      border-radius: 6px 6px 0 0;
      border: 1px solid var(--border);
      border-bottom: none;
    }

    .data-atlas-table-name {
      font-weight: 600;
      font-size: 14px;
      color: var(--text-primary);
    }

    .data-atlas-table-count {
      font-size: 12px;
      color: var(--text-muted);
      padding: 2px 8px;
      background: var(--bg-tertiary);
      border-radius: 10px;
    }

    .data-atlas-fields {
      border: 1px solid var(--border);
      border-radius: 0 0 6px 6px;
      overflow: hidden;
    }

    /* Field Card in Atlas */
    .field-atlas-card {
      display: grid;
      grid-template-columns: 32px 1fr auto;
      gap: 12px;
      padding: 12px 14px;
      border-bottom: 1px solid var(--border);
      align-items: start;
      transition: background 0.15s ease;
    }

    .field-atlas-card:last-child {
      border-bottom: none;
    }

    .field-atlas-card:hover {
      background: var(--bg-secondary);
    }

    .field-atlas-card.hidden-field {
      opacity: 0.5;
    }

    .field-atlas-checkbox {
      display: flex;
      align-items: center;
      justify-content: center;
      padding-top: 2px;
    }

    .field-atlas-checkbox input {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }

    .field-atlas-info {
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-width: 0;
    }

    .field-atlas-name {
      font-weight: 500;
      font-size: 14px;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .field-atlas-name .tier-badge {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      font-weight: 500;
    }

    .tier-badge.tier-1 {
      background: #dcfce7;
      color: #166534;
    }

    .tier-badge.tier-2 {
      background: #dbeafe;
      color: #1e40af;
    }

    .tier-badge.tier-3 {
      background: #fef3c7;
      color: #92400e;
    }

    .field-atlas-address {
      font-family: var(--font-mono);
      font-size: 11px;
      color: var(--accent-violet);
      background: var(--bg-secondary);
      padding: 3px 8px;
      border-radius: 4px;
      display: inline-block;
      max-width: fit-content;
    }

    .field-atlas-semantic {
      font-size: 12px;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .field-atlas-semantic .semantic-group {
      padding: 2px 8px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      font-size: 11px;
    }

    .field-atlas-placements {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .field-atlas-placements .placement-badge {
      font-size: 10px;
      padding: 2px 6px;
      background: var(--bg-tertiary);
      border-radius: 4px;
      color: var(--text-secondary);
    }

    .placement-badge.active {
      background: var(--accent-blue);
      color: white;
    }

    /* Screen Builder View */
    .screen-builder-container {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    .screen-builder-zones {
      flex: 1;
      overflow-y: auto;
      padding: 20px;
    }

    .screen-builder-palette {
      width: 280px;
      border-left: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      background: var(--bg-secondary);
    }

    /* Drop Zone */
    .drop-zone {
      background: var(--bg-card);
      border: 2px dashed var(--border);
      border-radius: 8px;
      margin-bottom: 16px;
      transition: all 0.15s ease;
    }

    .drop-zone.drag-over {
      border-color: var(--accent-blue);
      background: #eff6ff;
    }

    .drop-zone-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 16px;
      background: var(--bg-secondary);
      border-bottom: 1px dashed var(--border);
      border-radius: 6px 6px 0 0;
    }

    .drop-zone-title {
      font-weight: 500;
      font-size: 13px;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .drop-zone-title .zone-icon {
      font-size: 14px;
    }

    .drop-zone-count {
      font-size: 11px;
      color: var(--text-muted);
      padding: 2px 8px;
      background: var(--bg-tertiary);
      border-radius: 10px;
    }

    .drop-zone-content {
      padding: 12px;
      min-height: 60px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-content: flex-start;
    }

    .drop-zone-empty {
      width: 100%;
      text-align: center;
      color: var(--text-muted);
      font-size: 12px;
      padding: 16px;
    }

    /* Draggable Field Chip */
    .field-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 6px;
      font-size: 12px;
      cursor: grab;
      transition: all 0.15s ease;
      max-width: 200px;
    }

    .field-chip:hover {
      border-color: var(--accent-blue);
      box-shadow: var(--shadow-sm);
    }

    .field-chip.dragging {
      opacity: 0.5;
      cursor: grabbing;
    }

    .field-chip .chip-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .field-chip .chip-remove {
      width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg-secondary);
      border-radius: 50%;
      font-size: 10px;
      color: var(--text-muted);
      cursor: pointer;
      flex-shrink: 0;
    }

    .field-chip .chip-remove:hover {
      background: #fee2e2;
      color: #dc2626;
    }

    .field-chip .chip-address {
      font-family: var(--font-mono);
      font-size: 9px;
      color: var(--text-muted);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Field Palette */
    .palette-header {
      padding: 12px 16px;
      border-bottom: 1px solid var(--border);
      background: var(--bg-card);
    }

    .palette-title {
      font-weight: 500;
      font-size: 13px;
      color: var(--text-primary);
      margin-bottom: 8px;
    }

    .palette-search input {
      width: 100%;
      padding: 8px 10px;
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 12px;
      font-family: var(--font-sans);
    }

    .palette-fields {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }

    .palette-group {
      margin-bottom: 12px;
    }

    .palette-group-header {
      font-size: 11px;
      font-weight: 500;
      color: var(--text-muted);
      text-transform: uppercase;
      padding: 6px 8px;
      position: sticky;
      top: 0;
      background: var(--bg-secondary);
    }

    .palette-field {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: var(--bg-card);
      border: 1px solid var(--border);
      border-radius: 4px;
      margin-bottom: 4px;
      cursor: grab;
      transition: all 0.15s ease;
    }

    .palette-field:hover {
      border-color: var(--accent-blue);
    }

    .palette-field.in-use {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .palette-field-info {
      flex: 1;
      min-width: 0;
    }

    .palette-field-name {
      font-size: 12px;
      font-weight: 500;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .palette-field-address {
      font-family: var(--font-mono);
      font-size: 10px;
      color: var(--text-muted);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Field Matrix View */
    .field-matrix-container {
      flex: 1;
      overflow: auto;
      padding: 20px;
    }

    .field-matrix {
      min-width: 100%;
      border-collapse: collapse;
      font-size: 12px;
    }

    .field-matrix th,
    .field-matrix td {
      padding: 8px 12px;
      border: 1px solid var(--border);
      text-align: left;
    }

    .field-matrix th {
      background: var(--bg-secondary);
      font-weight: 500;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .field-matrix th.field-col {
      min-width: 250px;
      position: sticky;
      left: 0;
      z-index: 20;
    }

    .field-matrix td.field-col {
      position: sticky;
      left: 0;
      background: var(--bg-card);
      z-index: 5;
    }

    .field-matrix td.screen-col {
      text-align: center;
    }

    .field-matrix .matrix-check {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }

    .field-matrix .field-address {
      font-family: var(--font-mono);
      font-size: 10px;
      color: var(--accent-violet);
      display: block;
      margin-top: 2px;
    }

    /* Modal Footer */
    .field-canvas-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 20px;
      border-top: 1px solid var(--border);
      background: var(--bg-secondary);
      flex-shrink: 0;
    }

    .footer-info {
      font-size: 12px;
      color: var(--text-secondary);
    }

    .footer-actions {
      display: flex;
      gap: 8px;
    }

    .footer-btn {
      padding: 8px 16px;
      font-size: 13px;
      font-family: var(--font-sans);
      border-radius: 6px;
      cursor: pointer;
      transition: all 0.15s ease;
    }

    .footer-btn.secondary {
      border: 1px solid var(--border);
      background: var(--bg-card);
      color: var(--text-secondary);
    }

    .footer-btn.secondary:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
    }

    .footer-btn.primary {
      border: none;
      background: var(--accent-blue);
      color: white;
    }

    .footer-btn.primary:hover {
      background: #0284c7;
    }

    /* Configure Button in Settings Panel */
    .configure-layout-btn {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 10px 16px;
      background: linear-gradient(135deg, var(--accent-blue), var(--accent-violet));
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s ease;
      margin-bottom: 12px;
    }

    .configure-layout-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(3, 105, 161, 0.3);
    }

    .configure-layout-btn .btn-icon {
      font-size: 16px;
    }
  </style>
</head>
<body>

<div class="widget-container" id="app">
  <div class="loading">
    <div class="loading-spinner"></div>
    <span>Loading client data...</span>
  </div>
</div>

<!-- Config loaded separately for easy updates -->
<script src="config.js"></script>

<script>
(function() {
  'use strict';

  // ==========================================================================
  // CONFIGURATION
  // ==========================================================================

  const WEBHOOK_URL = 'https://n8n.intelechia.com/webhook/c68fda2a-9302-4efb-930b-7063b85ef595';
  const CONFIG = typeof ClientGlanceConfig !== 'undefined' ? ClientGlanceConfig : null;

  // ==========================================================================
  // SCHEMA PROCESSOR
  // Dynamically analyzes Airtable schema to determine field types and groupings
  // ==========================================================================

  const SchemaProcessor = {
    schema: null,
    fieldMap: new Map(),      // fieldName -> { type, options, tableName }
    tableMap: new Map(),      // tableName -> { fields: [] }

    /**
     * Initialize with schema data from API
     * @param {Array} schemaData - Array of table definitions with fields
     */
    init(schemaData) {
      if (!schemaData || !Array.isArray(schemaData)) {
        console.log('[SchemaProcessor] No schema provided, using fallback mode');
        return false;
      }

      this.schema = schemaData;
      this.fieldMap.clear();
      this.tableMap.clear();

      // Build field map from schema
      for (const table of schemaData) {
        const tableName = table.name;
        this.tableMap.set(tableName, {
          id: table.id,
          fields: table.fields,
          primaryFieldId: table.primaryFieldId
        });

        for (const field of table.fields || []) {
          // Store field with table context
          this.fieldMap.set(field.name, {
            type: field.type,
            options: field.options || {},
            id: field.id,
            tableName
          });

          // Also store with table prefix for disambiguation
          this.fieldMap.set(`${tableName}::${field.name}`, {
            type: field.type,
            options: field.options || {},
            id: field.id,
            tableName
          });
        }
      }

      console.log(`[SchemaProcessor] Loaded ${this.fieldMap.size} fields from ${this.tableMap.size} tables`);
      return true;
    },

    /**
     * Get field metadata from schema
     */
    getFieldMeta(fieldName) {
      return this.fieldMap.get(fieldName) || null;
    },

    /**
     * Get Airtable field type (not our display type)
     */
    getFieldType(fieldName) {
      const meta = this.getFieldMeta(fieldName);
      return meta?.type || null;
    },

    /**
     * Map Airtable field type to display format
     */
    getDisplayType(fieldName, value) {
      const airtableType = this.getFieldType(fieldName);

      // Map Airtable types to display types
      const typeMap = {
        'date': 'date',
        'dateTime': 'datetime',
        'createdTime': 'datetime',
        'lastModifiedTime': 'datetime',
        'email': 'email',
        'url': 'url',
        'phone': 'phone',  // Airtable doesn't have phone type, but we handle it
        'phoneNumber': 'phone',
        'checkbox': 'boolean',
        'number': 'number',
        'currency': 'currency',
        'percent': 'percent',
        'rating': 'rating',
        'duration': 'duration',
        'singleSelect': 'select',
        'multipleSelects': 'multiselect',
        'multipleRecordLinks': 'linked_records',
        'multipleLookupValues': 'lookup',
        'rollup': 'rollup',
        'formula': this.inferFormulaType.bind(this),
        'button': 'button',
        'multipleAttachments': 'attachment',
        'richText': 'richtext',
        'multilineText': 'text',
        'singleLineText': 'text',
        'autoNumber': 'number',
        'barcode': 'text',
        'lastModifiedBy': 'user',
        'createdBy': 'user'
      };

      const mapped = typeMap[airtableType];
      if (typeof mapped === 'function') {
        return mapped(fieldName, value);
      }
      return mapped || null;
    },

    /**
     * Infer type from formula result
     */
    inferFormulaType(fieldName, value) {
      const meta = this.getFieldMeta(fieldName);
      const resultType = meta?.options?.result?.type;

      if (resultType) {
        // Map the result type
        if (resultType === 'dateTime' || resultType === 'date') return 'date';
        if (resultType === 'number') return 'number';
        if (resultType === 'checkbox') return 'boolean';
      }

      // Fall back to value inference
      return null;
    },

    /**
     * Infer group from field name and type
     */
    inferGroup(fieldName, fieldType) {
      // First check schema-based grouping patterns
      const schemaGroups = this.getSchemaBasedGroup(fieldName);
      if (schemaGroups) return schemaGroups;

      // Immigration domain-specific patterns
      const fieldLower = fieldName.toLowerCase();

      // Court/Hearing related
      if (/hearing|court|judge|eoir|ich|merits|pleading|nta|calendar/.test(fieldLower)) {
        return 'Court';
      }

      // SIJ related
      if (/\bsij|custody|jdr|juvenile|child/.test(fieldLower)) {
        return 'SIJ';
      }

      // USCIS related
      if (/uscis|i-\d{3}|receipt|biometric|rfe|rfi|filing/.test(fieldLower)) {
        return 'USCIS';
      }

      // EAD related
      if (/\bead\b|work.*auth|employment.*auth/.test(fieldLower)) {
        return 'EAD';
      }

      // FOIA/Records
      if (/foia|fbi|obim|ice.*record|cbp.*record/.test(fieldLower)) {
        return 'Records';
      }

      // Appeals
      if (/appeal|brief|bia|circuit/.test(fieldLower)) {
        return 'Appeals';
      }

      // U-Visa
      if (/u-visa|u visa|uvisa|certification.*status/.test(fieldLower)) {
        return 'U-Visa';
      }

      // Asylum
      if (/asylum|i-589|credible.*fear|fear.*interview/.test(fieldLower)) {
        return 'Asylum';
      }

      // Bond
      if (/bond|detention|ice.*custody/.test(fieldLower)) {
        return 'Bond';
      }

      // Contact Info
      if (/phone|email|address|city|state|zip|contact/.test(fieldLower)) {
        return 'Contact';
      }

      // Identity
      if (/\bname\b|dob|birth|age|country|a#|a-number|gender|pronoun/.test(fieldLower)) {
        return 'Identity';
      }

      // Management
      if (/manager|attorney|atty|assigned|status|tag|case.*manager/.test(fieldLower)) {
        return 'Management';
      }

      // Documents/Links
      if (/document|file|box|link|url|scan|attachment/.test(fieldLower)) {
        return 'Documents';
      }

      // Notes
      if (/note|comment|memo/.test(fieldLower)) {
        return 'Notes';
      }

      // Financial
      if (/contract|payment|invoice|fee|retainer|\$|amount|price/.test(fieldLower)) {
        return 'Financial';
      }

      // Dates (generic)
      if (/date|time|deadline|due/.test(fieldLower) && fieldType === 'date') {
        return 'Dates';
      }

      return null;
    },

    /**
     * Use schema relationships to infer grouping
     */
    getSchemaBasedGroup(fieldName) {
      const meta = this.getFieldMeta(fieldName);
      if (!meta) return null;

      // If it's a lookup or rollup, try to get group from the linked table
      if (meta.type === 'multipleLookupValues' || meta.type === 'rollup') {
        const linkedFieldId = meta.options?.recordLinkFieldId;
        // Could trace back to linked table for grouping, but keep simple for now
      }

      return null;
    },

    /**
     * Get select options for a field
     */
    getSelectOptions(fieldName) {
      const meta = this.getFieldMeta(fieldName);
      if (!meta?.options?.choices) return null;
      return meta.options.choices.map(c => ({ id: c.id, name: c.name, color: c.color }));
    },

    /**
     * Check if field should be hidden based on schema
     */
    shouldHideField(fieldName) {
      const meta = this.getFieldMeta(fieldName);
      if (!meta) return false;

      // Hide internal/system fields
      const hiddenTypes = ['lastModifiedBy', 'createdBy', 'autoNumber'];
      if (hiddenTypes.includes(meta.type)) return true;

      // Hide fields that are purely internal
      const hiddenPatterns = [
        /^record.*id$/i,
        /^airtable.*id$/i,
        /_id$/i,
        /^id$/i,
        /sync|push|calc|internal/i
      ];

      return hiddenPatterns.some(p => p.test(fieldName));
    },

    /**
     * Generate a smart display label for a field
     */
    getDisplayLabel(fieldName) {
      // Remove common suffixes
      let label = fieldName
        .replace(/\s*\(from.*\)$/i, '')  // Remove "(from Table)" lookups
        .replace(/_/g, ' ')
        .replace(/([A-Z])/g, ' $1')
        .trim();

      // Capitalize first letter
      return label.charAt(0).toUpperCase() + label.slice(1);
    },

    /**
     * Get all fields for a table
     */
    getTableFields(tableName) {
      const table = this.tableMap.get(tableName);
      return table?.fields || [];
    },

    /**
     * Check if schema is loaded
     */
    hasSchema() {
      return this.schema !== null && this.fieldMap.size > 0;
    }
  };

  // ==========================================================================
  // MATTER DETECTOR
  // Detects case types (matters) from case records
  // ==========================================================================

  const MatterDetector = {
    /**
     * Detect all matters for a client from their case records
     * @param {Array} cases - Array of case records from CMV
     * @returns {Array} Array of detected matter objects
     */
    detectMatters(cases) {
      if (!cases || !Array.isArray(cases)) return [];

      const matterTypes = CONFIG?.MATTER_TYPES || {};
      const detectedMatters = [];

      for (const caseRecord of cases) {
        const caseFields = caseRecord.fields || caseRecord;
        const caseId = caseRecord.recordId || caseRecord.id;
        const caseIdentifier = caseRecord.caseIdentifier || '';

        // Try to detect matter type from case identifier/description
        for (const [typeId, typeConfig] of Object.entries(matterTypes)) {
          const patterns = typeConfig.detectPatterns || [];
          const matched = patterns.some(p => p.test(caseIdentifier));

          if (matched) {
            // Get status from the appropriate field
            const statusValue = typeConfig.statusField
              ? caseFields[typeConfig.statusField]
              : null;

            detectedMatters.push({
              id: `${typeId}-${caseId}`,
              type: typeId,
              typeConfig,
              caseId,
              caseIdentifier,
              status: statusValue,
              fields: this.extractMatterFields(caseFields, typeConfig)
            });
          }
        }

        // If no specific type detected, check for generic matter
        if (!detectedMatters.some(m => m.caseId === caseId)) {
          // Try to infer from status fields
          for (const [typeId, typeConfig] of Object.entries(matterTypes)) {
            const statusField = typeConfig.statusField;
            if (statusField && caseFields[statusField]) {
              detectedMatters.push({
                id: `${typeId}-${caseId}`,
                type: typeId,
                typeConfig,
                caseId,
                caseIdentifier,
                status: caseFields[statusField],
                fields: this.extractMatterFields(caseFields, typeConfig)
              });
              break;
            }
          }
        }
      }

      return detectedMatters;
    },

    /**
     * Extract fields relevant to a matter type
     */
    extractMatterFields(caseFields, typeConfig) {
      const relevantFields = {};
      const relatedFieldNames = typeConfig.relatedFields || [];

      for (const fieldName of relatedFieldNames) {
        if (caseFields[fieldName] !== undefined && caseFields[fieldName] !== null) {
          relevantFields[fieldName] = caseFields[fieldName];
        }
      }

      return relevantFields;
    },

    /**
     * Get matter type config by ID
     */
    getMatterConfig(typeId) {
      return CONFIG?.MATTER_TYPES?.[typeId] || null;
    },

    /**
     * Determine the color class for a status value
     */
    getStatusColor(status) {
      if (!status) return 'gray';

      const statusLower = String(status).toLowerCase();
      const colorMap = CONFIG?.FIELD_DISPLAY_TYPES?.status?.colorMap || {};

      for (const [keyword, color] of Object.entries(colorMap)) {
        if (statusLower.includes(keyword)) {
          return color;
        }
      }

      return 'gray';
    },

    /**
     * Calculate urgency for a date
     */
    getDateUrgency(dateValue) {
      if (!dateValue) return null;

      try {
        const date = new Date(dateValue);
        const now = new Date();
        const diffDays = Math.ceil((date - now) / (1000 * 60 * 60 * 24));

        const thresholds = CONFIG?.FIELD_DISPLAY_TYPES?.date?.urgencyThresholds || {
          urgent: 7,
          upcoming: 30,
          scheduled: 90
        };

        if (diffDays < 0) return 'past';
        if (diffDays <= thresholds.urgent) return 'urgent';
        if (diffDays <= thresholds.upcoming) return 'upcoming';
        if (diffDays <= thresholds.scheduled) return 'scheduled';
        return 'future';
      } catch {
        return null;
      }
    }
  };

  // ==========================================================================
  // FIELD CLASSIFIER
  // Determines if fields are semantic (meaningful) or structural (plumbing)
  // ==========================================================================

  const FieldClassifier = {
    /**
     * Check if a field is structural (should be hidden)
     */
    isStructural(fieldName, fieldType = null) {
      const classification = CONFIG?.FIELD_CLASSIFICATION || {};

      // Check structural patterns
      const structuralPatterns = classification.structuralPatterns || [];
      if (structuralPatterns.some(p => p.test(fieldName))) {
        // But check if it matches meaningful patterns (override)
        const meaningfulPatterns = classification.meaningfulPatterns || [];
        if (meaningfulPatterns.some(p => p.test(fieldName))) {
          return false; // Meaningful overrides structural
        }
        return true;
      }

      // Check structural types
      const structuralTypes = classification.structuralTypes || [];
      if (fieldType && structuralTypes.includes(fieldType)) {
        return true;
      }

      // Check maybe-structural types (need pattern check)
      const maybeTypes = classification.maybeStructuralTypes || [];
      if (fieldType && maybeTypes.includes(fieldType)) {
        // These are structural unless they match meaningful patterns
        const meaningfulPatterns = classification.meaningfulPatterns || [];
        return !meaningfulPatterns.some(p => p.test(fieldName));
      }

      return false;
    },

    /**
     * Check if a field is high-priority (should always show)
     */
    isPriority(fieldName) {
      const tiers = CONFIG?.FIELD_PRIORITY_TIERS || {};
      const critical = tiers.critical || [];
      const important = tiers.important || [];

      return critical.includes(fieldName) || important.includes(fieldName);
    },

    /**
     * Check if a field should trigger urgency display
     */
    isUrgencyField(fieldName) {
      const urgencyFields = CONFIG?.FIELD_PRIORITY_TIERS?.urgencyFields || [];
      return urgencyFields.includes(fieldName);
    }
  };

  // ==========================================================================
  // TUPLE PROCESSOR
  // Processes fields into semantic tuples for display
  // ==========================================================================

  const TupleProcessor = {
    /**
     * Build tuples from processed fields
     * @param {Array} fields - Processed field objects
     * @param {Array} matters - Detected matters
     * @returns {Array} Array of tuple objects with fields populated
     */
    buildTuples(fields, matters) {
      const tupleConfigs = CONFIG?.SEMANTIC_TUPLES || {};
      const tuples = [];

      for (const [tupleId, tupleConfig] of Object.entries(tupleConfigs)) {
        const tuple = {
          id: tupleId,
          label: tupleConfig.label,
          priority: tupleConfig.priority || 99,
          matterType: tupleConfig.matterType,
          matterAgnostic: tupleConfig.matterAgnostic,
          fields: []
        };

        // Get field values for this tuple
        for (const fieldSpec of tupleConfig.fields || []) {
          const fieldName = fieldSpec.name;
          const matchingFields = fields.filter(f => f.fieldName === fieldName);

          if (matchingFields.length > 0) {
            // Take the first match (or aggregate if multiple)
            const field = matchingFields[0];
            tuple.fields.push({
              ...field,
              format: fieldSpec.format,
              displayAs: fieldSpec.displayAs,
              urgency: fieldSpec.urgency ? MatterDetector.getDateUrgency(field.value) : null
            });
          }
        }

        // Only include tuple if it has at least one field with a value
        if (tuple.fields.length > 0) {
          // Check if this tuple applies to any detected matter
          if (tuple.matterType) {
            const relevantMatter = matters.find(m => m.type === tuple.matterType);
            if (relevantMatter) {
              tuple.matter = relevantMatter;
              tuples.push(tuple);
            }
          } else if (tuple.matterAgnostic || tupleId === 'identity' || tupleId === 'contact' || tupleId === 'management') {
            // Matter-agnostic tuples always show
            tuples.push(tuple);
          }
        }
      }

      // Sort by priority
      tuples.sort((a, b) => a.priority - b.priority);

      return tuples;
    },

    /**
     * Get tuple status (from its status field)
     */
    getTupleStatus(tuple) {
      const statusField = tuple.fields.find(f => f.displayAs === 'status');
      return statusField?.value || null;
    }
  };

  // ==========================================================================
  // NARRATIVE COMPOSER
  // Composes short and long narratives from client data
  // ==========================================================================

  const NarrativeComposer = {
    pronouns: { subject: 'They', object: 'them', possessive: 'their' },

    /**
     * Set pronouns based on client data
     */
    setPronouns(clientFields) {
      const gender = clientFields?.Gender?.toLowerCase?.();
      const pronounsField = clientFields?.Pronouns?.toLowerCase?.();

      if (pronounsField) {
        if (pronounsField.includes('she') || pronounsField.includes('her')) {
          this.pronouns = { subject: 'She', object: 'her', possessive: 'her' };
        } else if (pronounsField.includes('he') || pronounsField.includes('him')) {
          this.pronouns = { subject: 'He', object: 'him', possessive: 'his' };
        } else {
          this.pronouns = { subject: 'They', object: 'them', possessive: 'their' };
        }
        return;
      }

      if (gender === 'female' || gender === 'f') {
        this.pronouns = { subject: 'She', object: 'her', possessive: 'her' };
      } else if (gender === 'male' || gender === 'm') {
        this.pronouns = { subject: 'He', object: 'him', possessive: 'his' };
      } else {
        this.pronouns = { subject: 'They', object: 'them', possessive: 'their' };
      }
    },

    /**
     * Compose short narrative (overview)
     */
    composeShort(clientInfo, matters, upcomingEvents) {
      const sentences = [];
      const fields = clientInfo?.fields || {};

      // Identity sentence
      const name = fields['Client Name'];
      const aNum = fields['A#'];
      const age = fields['Age'];
      const country = fields['Country'];

      if (name) {
        let identity = name;
        if (aNum) identity += ` (A# ${aNum})`;
        if (age) identity += `, age ${age}`;
        if (country) identity += `, from ${country}`;
        sentences.push(identity);
      }

      // Matters sentence
      if (matters.length > 0) {
        const matterDescriptions = matters.map(m => {
          const label = m.typeConfig?.label || m.type;
          const status = m.status ? ` (${String(m.status).toLowerCase()})` : '';
          return label + status;
        });

        const verb = matters.length === 1 ? 'has' : 'have';
        sentences.push(`${this.pronouns.subject} ${verb} ${matterDescriptions.join(' and ')} matter${matters.length > 1 ? 's' : ''}`);
      }

      // Next date sentence
      if (upcomingEvents.length > 0) {
        const next = upcomingEvents[0];
        sentences.push(`Next: ${next.title} on ${Utils.formatDate(next.date)}`);
      }

      return sentences.join('. ') + (sentences.length ? '.' : '');
    },

    /**
     * Compose long narrative (full detail)
     */
    composeLong(clientInfo, matters, tuples, events, applications) {
      const sections = [];
      const fields = clientInfo?.fields || {};

      // IDENTITY SECTION
      const identityParts = [];
      const name = fields['Client Name'];
      const aNum = fields['A#'];
      const age = fields['Age'];
      const gender = fields['Gender'];
      const country = fields['Country'];
      const dob = fields['DOB'];
      const entryDate = fields['Entry Date'];
      const entryStatus = fields['Entry Status'];
      const placeOfEntry = fields['Place of Entry'];
      const address = fields['Address'];
      const phone = fields['Phone Number'];
      const email = fields['Client Email'];

      if (name) {
        let idSentence = `${name}`;
        if (aNum) idSentence += ` (A# ${aNum})`;
        if (age && gender) {
          idSentence += ` is a ${age}-year-old ${String(gender).toLowerCase()}`;
        } else if (age) {
          idSentence += ` is ${age} years old`;
        }
        if (country) idSentence += ` from ${country}`;
        identityParts.push(idSentence);
      }

      if (dob) {
        identityParts.push(`Date of birth: ${Utils.formatDate(dob)}`);
      }

      if (entryDate) {
        let entrySentence = `Entered the United States on ${Utils.formatDate(entryDate)}`;
        if (placeOfEntry) entrySentence += ` at ${placeOfEntry}`;
        if (entryStatus) entrySentence += ` (${entryStatus})`;
        identityParts.push(entrySentence);
      }

      if (address || phone || email) {
        const contactParts = [];
        if (address) contactParts.push(`Address: ${address}`);
        if (phone) contactParts.push(`Phone: ${Utils.formatPhone(phone)}`);
        if (email) contactParts.push(`Email: ${email}`);
        identityParts.push(contactParts.join('. '));
      }

      if (identityParts.length > 0) {
        sections.push({
          title: 'CLIENT IDENTITY',
          content: identityParts.join('. ') + '.'
        });
      }

      // MATTERS SECTIONS
      for (const matter of matters) {
        const matterLabel = matter.typeConfig?.label || matter.type.toUpperCase();
        const matterParts = [];

        if (matter.status) {
          matterParts.push(`Status: ${matter.status}`);
        }

        // Get related tuple
        const relatedTuple = tuples.find(t => t.matterType === matter.type);
        if (relatedTuple) {
          for (const field of relatedTuple.fields) {
            if (field.displayAs !== 'status' && field.value) {
              const label = field.displayLabel || Utils.humanizeFieldName(field.fieldName);
              let value = field.value;
              if (field.format === 'date') value = Utils.formatDate(value);
              matterParts.push(`${label}: ${value}`);
            }
          }
        }

        if (matterParts.length > 0) {
          sections.push({
            title: `${matterLabel} CASE`,
            content: matterParts.join('. ') + '.'
          });
        }
      }

      // UPCOMING EVENTS
      if (events.length > 0) {
        const eventLines = events.slice(0, 5).map(e => {
          let line = `‚Ä¢ ${Utils.formatDate(e.date)}: ${e.title}`;
          if (e.matter) line += ` (${e.matter})`;
          return line;
        });

        sections.push({
          title: 'UPCOMING EVENTS',
          content: eventLines.join('\n')
        });
      }

      // APPLICATIONS
      if (applications.length > 0) {
        const appLines = applications.map(a => {
          let line = `‚Ä¢ ${a.application || a.name}`;
          if (a.status) line += `: ${a.status}`;
          if (a.receiptNumber) line += ` (${a.receiptNumber})`;
          return line;
        });

        sections.push({
          title: 'APPLICATIONS',
          content: appLines.join('\n')
        });
      }

      return sections;
    }
  };

  // ==========================================================================
  // FIELD PREFERENCES
  // Manages user preferences for which fields to show in each tab
  // Stored in localStorage
  // ==========================================================================

  const FieldPreferences = {
    storageKey: CONFIG?.STORAGE_KEY || 'clientGlance_fieldPrefs',
    preferences: null,

    /**
     * Load preferences from localStorage or use defaults
     */
    load() {
      try {
        const stored = localStorage.getItem(this.storageKey);
        if (stored) {
          this.preferences = JSON.parse(stored);
          console.log('[FieldPreferences] Loaded from localStorage');
        } else {
          this.preferences = this.getDefaults();
          console.log('[FieldPreferences] Using defaults');
        }
      } catch (e) {
        console.warn('[FieldPreferences] Error loading preferences:', e.message);
        this.preferences = this.getDefaults();
      }
      return this.preferences;
    },

    /**
     * Get default field visibility from config
     */
    getDefaults() {
      const defaults = {};
      const tabs = CONFIG?.MAIN_TABS || {};

      for (const [tabId, tabConfig] of Object.entries(tabs)) {
        defaults[tabId] = {
          visibleFields: [...(tabConfig.defaultFields || [])],
          hiddenFields: [...(tabConfig.alwaysHidden || [])]
        };
      }

      return defaults;
    },

    /**
     * Save preferences to localStorage
     */
    save() {
      try {
        localStorage.setItem(this.storageKey, JSON.stringify(this.preferences));
        console.log('[FieldPreferences] Saved to localStorage');
      } catch (e) {
        console.warn('[FieldPreferences] Error saving preferences:', e.message);
      }
    },

    /**
     * Reset to defaults
     */
    reset() {
      this.preferences = this.getDefaults();
      this.save();
      return this.preferences;
    },

    /**
     * Check if a field should be visible in a tab
     */
    isFieldVisible(tabId, fieldName) {
      if (!this.preferences) this.load();

      const tabPrefs = this.preferences[tabId];
      if (!tabPrefs) return true;

      // Always hidden fields are never shown
      if (tabPrefs.hiddenFields?.includes(fieldName)) return false;

      // Check if in visible list
      return tabPrefs.visibleFields?.includes(fieldName) ?? false;
    },

    /**
     * Toggle field visibility
     */
    toggleField(tabId, fieldName, visible) {
      if (!this.preferences) this.load();

      if (!this.preferences[tabId]) {
        this.preferences[tabId] = { visibleFields: [], hiddenFields: [] };
      }

      const visibleFields = this.preferences[tabId].visibleFields || [];

      if (visible && !visibleFields.includes(fieldName)) {
        visibleFields.push(fieldName);
      } else if (!visible) {
        const idx = visibleFields.indexOf(fieldName);
        if (idx > -1) visibleFields.splice(idx, 1);
      }

      this.preferences[tabId].visibleFields = visibleFields;
      this.save();
    },

    /**
     * Get all visible fields for a tab
     */
    getVisibleFields(tabId) {
      if (!this.preferences) this.load();
      return this.preferences[tabId]?.visibleFields || [];
    },

    /**
     * Set visible fields for a tab (batch update)
     */
    setVisibleFields(tabId, fieldNames) {
      if (!this.preferences) this.load();

      if (!this.preferences[tabId]) {
        this.preferences[tabId] = { visibleFields: [], hiddenFields: [] };
      }

      this.preferences[tabId].visibleFields = [...fieldNames];
      this.save();
    },

    /**
     * Check if a field should always be hidden (internal fields)
     */
    isAlwaysHidden(tabId, fieldName) {
      const tabConfig = CONFIG?.MAIN_TABS?.[tabId];
      if (!tabConfig) return false;

      return tabConfig.alwaysHidden?.some(pattern => {
        if (pattern instanceof RegExp) {
          return pattern.test(fieldName);
        }
        return pattern === fieldName;
      }) ?? false;
    }
  };

  // ==========================================================================
  // FIELD REGISTRY
  // Unified registry of all fields with their tuple addresses
  // ==========================================================================

  const FieldRegistry = {
    registry: new Map(), // fieldKey -> field metadata
    tableFields: new Map(), // tableName -> Set of fieldNames
    initialized: false,

    /**
     * Initialize registry from available data sources
     */
    init(data, processedFields) {
      if (this.initialized) return;

      // Build registry from processed fields
      if (processedFields && Array.isArray(processedFields)) {
        for (const field of processedFields) {
          this.registerField(field);
        }
      }

      // Also incorporate schema information
      if (SchemaProcessor.hasSchema()) {
        for (const [fieldName, meta] of SchemaProcessor.fieldMap) {
          if (!this.registry.has(fieldName)) {
            this.registerFromSchema(fieldName, meta);
          }
        }
      }

      this.initialized = true;
      console.log(`[FieldRegistry] Initialized with ${this.registry.size} fields`);
    },

    /**
     * Register a field from processed field data
     */
    registerField(field) {
      const key = field.fieldName;
      const sourceTable = field.sourceTable || this.inferTable(field);

      // Build tuple address
      const tupleAddress = `${sourceTable}.${field.fieldName}`;

      // Get semantic info
      const semanticRole = CONFIG?.SEMANTIC_ROLES?.[field.fieldName];
      const semanticGroup = field.group || semanticRole?.group || 'Uncategorized';
      const semanticAddress = semanticRole
        ? `${semanticGroup.toLowerCase()}.${semanticRole.role}`
        : null;

      const entry = {
        fieldName: field.fieldName,
        displayName: field.displayLabel || Utils.humanizeFieldName(field.fieldName),
        tupleAddress,
        sourceTable,
        semanticAddress,
        semanticGroup,
        tier: field.tier || this.inferTier(field.fieldName),
        dataType: field.dataType || field.schemaType || 'text',
        schemaType: field.schemaType,
        isStructural: SchemaProcessor.shouldHideField?.(field.fieldName) || false,
        placements: new Map(), // tabId -> Set of zoneIds
        priority: semanticRole?.priority || 99,
        template: semanticRole?.template || null,
        currentValue: field.value
      };

      this.registry.set(key, entry);

      // Track by table
      if (!this.tableFields.has(sourceTable)) {
        this.tableFields.set(sourceTable, new Set());
      }
      this.tableFields.get(sourceTable).add(key);
    },

    /**
     * Register field from schema only (no value)
     */
    registerFromSchema(fieldName, meta) {
      const sourceTable = meta.tableName || 'Unknown';
      const tupleAddress = `${sourceTable}.${fieldName}`;

      const semanticRole = CONFIG?.SEMANTIC_ROLES?.[fieldName];
      const semanticGroup = SchemaProcessor.inferGroup?.(fieldName, meta.type) ||
                           semanticRole?.group || 'Uncategorized';

      const entry = {
        fieldName,
        displayName: SchemaProcessor.getDisplayLabel?.(fieldName) || Utils.humanizeFieldName(fieldName),
        tupleAddress,
        sourceTable,
        semanticAddress: semanticRole ? `${semanticGroup.toLowerCase()}.${semanticRole.role}` : null,
        semanticGroup,
        tier: this.inferTier(fieldName),
        dataType: meta.type || 'text',
        schemaType: meta.type,
        isStructural: SchemaProcessor.shouldHideField?.(fieldName) || false,
        placements: new Map(),
        priority: semanticRole?.priority || 99,
        template: semanticRole?.template || null,
        currentValue: null
      };

      this.registry.set(fieldName, entry);

      if (!this.tableFields.has(sourceTable)) {
        this.tableFields.set(sourceTable, new Set());
      }
      this.tableFields.get(sourceTable).add(fieldName);
    },

    /**
     * Infer which table a field belongs to
     */
    inferTable(field) {
      if (field.sourceTable) return field.sourceTable;
      if (field.caseLabel) return 'Case Master View';

      // Check schema
      const meta = SchemaProcessor.getFieldMeta?.(field.fieldName);
      if (meta?.tableName) return meta.tableName;

      // Infer from field patterns
      const name = field.fieldName.toLowerCase();
      if (/client.*name|a#|dob|country|phone|email|address|gender|pronoun/i.test(name)) {
        return 'Client Info';
      }
      if (/hearing|court|judge|status|uscis|ead|asylum|sij|bond|appeal/i.test(name)) {
        return 'Case Master View';
      }
      if (/event|calendar/i.test(name)) {
        return 'Events';
      }
      if (/application|receipt|filing/i.test(name)) {
        return 'Applications';
      }

      return 'Unknown';
    },

    /**
     * Infer tier from field name
     */
    inferTier(fieldName) {
      // Tier 1: Has semantic role
      if (CONFIG?.SEMANTIC_ROLES?.[fieldName]) return 1;

      // Tier 2: Matches group pattern
      const patterns = CONFIG?.FIELD_GROUP_PATTERNS || [];
      for (const p of patterns) {
        if (p.pattern.test(fieldName)) return 2;
      }

      // Tier 3: Everything else
      return 3;
    },

    /**
     * Get all fields grouped by source table
     */
    getFieldsByTable() {
      const result = {};
      for (const [tableName, fieldNames] of this.tableFields) {
        result[tableName] = Array.from(fieldNames)
          .map(name => this.registry.get(name))
          .filter(Boolean)
          .sort((a, b) => a.priority - b.priority);
      }
      return result;
    },

    /**
     * Get all fields as flat array
     */
    getAllFields() {
      return Array.from(this.registry.values());
    },

    /**
     * Get field by name
     */
    getField(fieldName) {
      return this.registry.get(fieldName);
    },

    /**
     * Set field placement for a tab/zone
     */
    setPlacement(fieldName, tabId, zoneId) {
      const field = this.registry.get(fieldName);
      if (!field) return;

      if (!field.placements.has(tabId)) {
        field.placements.set(tabId, new Set());
      }
      field.placements.get(tabId).add(zoneId);
    },

    /**
     * Remove field from a zone
     */
    removePlacement(fieldName, tabId, zoneId) {
      const field = this.registry.get(fieldName);
      if (!field || !field.placements.has(tabId)) return;

      field.placements.get(tabId).delete(zoneId);
    },

    /**
     * Get all placements for a field
     */
    getPlacements(fieldName) {
      const field = this.registry.get(fieldName);
      if (!field) return {};

      const result = {};
      for (const [tabId, zones] of field.placements) {
        result[tabId] = Array.from(zones);
      }
      return result;
    },

    /**
     * Search fields by name or address
     */
    search(query) {
      const q = query.toLowerCase();
      return Array.from(this.registry.values()).filter(field =>
        field.fieldName.toLowerCase().includes(q) ||
        field.tupleAddress.toLowerCase().includes(q) ||
        field.displayName.toLowerCase().includes(q) ||
        (field.semanticAddress && field.semanticAddress.toLowerCase().includes(q))
      );
    },

    /**
     * Filter fields by criteria
     */
    filter({ table, tier, group, includeStructural = false }) {
      return Array.from(this.registry.values()).filter(field => {
        if (!includeStructural && field.isStructural) return false;
        if (table && field.sourceTable !== table) return false;
        if (tier && field.tier !== tier) return false;
        if (group && field.semanticGroup !== group) return false;
        return true;
      });
    }
  };

  // ==========================================================================
  // SCREEN ZONES
  // Defines available zones per screen/tab type
  // ==========================================================================

  const ScreenZones = {
    // Zone definitions per tab type
    definitions: {
      overview: {
        zones: [
          { id: 'narrative', label: 'Narrative Summary', icon: 'üìù', description: 'Fields included in the narrative text' },
          { id: 'header', label: 'Header Info', icon: 'üë§', description: 'Key identifiers shown at top' },
          { id: 'status-cards', label: 'Status Cards', icon: 'üìä', description: 'Matter status badges' },
          { id: 'events-panel', label: 'Upcoming Events', icon: 'üìÖ', description: 'Scheduled dates and deadlines' }
        ],
        layout: 'dashboard'
      },
      matters: {
        zones: [
          { id: 'card-header', label: 'Card Header', icon: 'üè∑Ô∏è', description: 'Top of each matter card' },
          { id: 'card-status', label: 'Status Badge', icon: 'üîµ', description: 'Status indicator on card' },
          { id: 'card-body', label: 'Card Details', icon: 'üìã', description: 'Main content area' },
          { id: 'card-dates', label: 'Key Dates', icon: 'üìÜ', description: 'Important dates section' }
        ],
        layout: 'card-grid'
      },
      events: {
        zones: [
          { id: 'event-header', label: 'Event Title', icon: 'üìå', description: 'Event name and type' },
          { id: 'event-datetime', label: 'Date & Time', icon: 'üïê', description: 'When the event occurs' },
          { id: 'event-location', label: 'Location', icon: 'üìç', description: 'Where the event takes place' },
          { id: 'event-details', label: 'Details', icon: 'üìù', description: 'Additional event info' }
        ],
        layout: 'timeline'
      },
      applications: {
        zones: [
          { id: 'app-type', label: 'Application Type', icon: 'üìÑ', description: 'Form number and name' },
          { id: 'app-status', label: 'Status', icon: 'üîµ', description: 'Current status' },
          { id: 'app-receipt', label: 'Receipt Info', icon: 'üî¢', description: 'Receipt number and date' },
          { id: 'app-details', label: 'Details', icon: 'üìã', description: 'Additional application info' }
        ],
        layout: 'cards'
      },
      notes: {
        zones: [
          { id: 'note-content', label: 'Note Content', icon: 'üìù', description: 'The note text' },
          { id: 'note-meta', label: 'Metadata', icon: 'üè∑Ô∏è', description: 'Date, source, matter' }
        ],
        layout: 'feed'
      },
      timeline: {
        zones: [
          { id: 'timeline-date', label: 'Date', icon: 'üìÖ', description: 'When it happened' },
          { id: 'timeline-event', label: 'Event', icon: 'üìå', description: 'What happened' },
          { id: 'timeline-details', label: 'Details', icon: 'üìã', description: 'Additional context' }
        ],
        layout: 'chronological'
      },
      client: {
        zones: [
          { id: 'identity-hero', label: 'Hero Section', icon: 'üë§', description: 'Name and key identifiers' },
          { id: 'identity-details', label: 'Identity Details', icon: 'ü™™', description: 'DOB, country, etc.' },
          { id: 'contact-info', label: 'Contact Info', icon: 'üìû', description: 'Phone, email, address' },
          { id: 'entry-info', label: 'Entry Info', icon: 'üõ¨', description: 'Entry date, status, place' }
        ],
        layout: 'structured'
      }
    },

    /**
     * Get zones for a tab
     */
    getZonesForTab(tabId) {
      return this.definitions[tabId]?.zones || [];
    },

    /**
     * Get layout type for a tab
     */
    getLayoutForTab(tabId) {
      return this.definitions[tabId]?.layout || 'structured';
    },

    /**
     * Get all zone IDs for a tab
     */
    getZoneIds(tabId) {
      return this.getZonesForTab(tabId).map(z => z.id);
    }
  };

  // ==========================================================================
  // LAYOUT PREFERENCES
  // Stores user's custom field placements per tab/zone
  // ==========================================================================

  const LayoutPreferences = {
    storageKey: 'clientGlance_layoutPrefs',
    preferences: null,

    load() {
      try {
        const stored = localStorage.getItem(this.storageKey);
        if (stored) {
          this.preferences = JSON.parse(stored);
          console.log('[LayoutPreferences] Loaded from localStorage');
        } else {
          this.preferences = this.getDefaults();
        }
      } catch (e) {
        console.warn('[LayoutPreferences] Error loading:', e.message);
        this.preferences = this.getDefaults();
      }
      return this.preferences;
    },

    getDefaults() {
      return {
        tabs: {},
        version: 1
      };
    },

    save() {
      try {
        localStorage.setItem(this.storageKey, JSON.stringify(this.preferences));
        console.log('[LayoutPreferences] Saved');
      } catch (e) {
        console.warn('[LayoutPreferences] Error saving:', e.message);
      }
    },

    /**
     * Get zone contents for a tab
     */
    getZoneContents(tabId, zoneId) {
      if (!this.preferences) this.load();
      return this.preferences.tabs?.[tabId]?.zones?.[zoneId] || [];
    },

    /**
     * Set zone contents for a tab
     */
    setZoneContents(tabId, zoneId, fieldNames) {
      if (!this.preferences) this.load();

      if (!this.preferences.tabs[tabId]) {
        this.preferences.tabs[tabId] = { zones: {} };
      }

      this.preferences.tabs[tabId].zones[zoneId] = [...fieldNames];
      this.save();
    },

    /**
     * Add field to a zone
     */
    addToZone(tabId, zoneId, fieldName) {
      const current = this.getZoneContents(tabId, zoneId);
      if (!current.includes(fieldName)) {
        current.push(fieldName);
        this.setZoneContents(tabId, zoneId, current);
      }
    },

    /**
     * Remove field from a zone
     */
    removeFromZone(tabId, zoneId, fieldName) {
      const current = this.getZoneContents(tabId, zoneId);
      const idx = current.indexOf(fieldName);
      if (idx > -1) {
        current.splice(idx, 1);
        this.setZoneContents(tabId, zoneId, current);
      }
    },

    /**
     * Move field from one zone to another
     */
    moveField(fieldName, fromTabId, fromZoneId, toTabId, toZoneId) {
      this.removeFromZone(fromTabId, fromZoneId, fieldName);
      this.addToZone(toTabId, toZoneId, fieldName);
    },

    /**
     * Get all field placements for a tab
     */
    getTabLayout(tabId) {
      if (!this.preferences) this.load();
      return this.preferences.tabs?.[tabId]?.zones || {};
    },

    /**
     * Check if field is placed in any zone of a tab
     */
    isFieldPlaced(tabId, fieldName) {
      const layout = this.getTabLayout(tabId);
      for (const zoneFields of Object.values(layout)) {
        if (zoneFields.includes(fieldName)) return true;
      }
      return false;
    },

    /**
     * Reset tab to defaults
     */
    resetTab(tabId) {
      if (!this.preferences) this.load();
      delete this.preferences.tabs[tabId];
      this.save();
    }
  };

  // ==========================================================================
  // FIELD CANVAS
  // Visual field configuration UI
  // ==========================================================================

  const FieldCanvas = {
    isOpen: false,
    currentTab: null,
    activeView: 'atlas', // 'atlas', 'builder', 'matrix'
    searchQuery: '',
    filterTable: 'all',
    filterTier: 'all',
    pendingChanges: new Map(), // Track unsaved changes
    draggedField: null,

    /**
     * Open the Field Canvas modal
     */
    open(tabId) {
      this.currentTab = tabId;
      this.isOpen = true;
      this.pendingChanges.clear();

      // Initialize registry if needed
      if (!FieldRegistry.initialized && window.ClientGlanceWidget?.processedFields) {
        FieldRegistry.init(null, window.ClientGlanceWidget.processedFields);
      }

      this.render();

      // Animate in
      requestAnimationFrame(() => {
        const overlay = document.getElementById('field-canvas-overlay');
        if (overlay) overlay.classList.add('visible');
      });

      console.log('[FieldCanvas] Opened for tab:', tabId);
    },

    /**
     * Close the modal
     */
    close() {
      const overlay = document.getElementById('field-canvas-overlay');
      if (overlay) {
        overlay.classList.remove('visible');
        setTimeout(() => {
          this.isOpen = false;
          this.render();
        }, 200);
      }
    },

    /**
     * Save changes and close
     */
    save() {
      // Apply pending changes to LayoutPreferences
      for (const [key, value] of this.pendingChanges) {
        const [tabId, zoneId] = key.split('::');
        LayoutPreferences.setZoneContents(tabId, zoneId, value);
      }

      this.pendingChanges.clear();
      this.close();

      // Trigger re-render of main widget
      if (window.ClientGlanceWidget) {
        window.ClientGlanceWidget.render();
      }
    },

    /**
     * Render the Field Canvas modal
     */
    render() {
      // Remove existing overlay if any
      const existing = document.getElementById('field-canvas-overlay');
      if (existing) existing.remove();

      if (!this.isOpen) return;

      const tabConfig = CONFIG?.MAIN_TABS?.[this.currentTab];
      const tabLabel = tabConfig?.label || this.currentTab;

      const html = `
        <div class="field-canvas-overlay" id="field-canvas-overlay">
          <div class="field-canvas-modal">
            <div class="field-canvas-header">
              <div class="field-canvas-title">
                <h2>Configure Fields</h2>
                <span class="tab-context">${Utils.escapeHtml(tabLabel)} Tab</span>
              </div>
              <button class="field-canvas-close" data-action="close-canvas">&times;</button>
            </div>

            <div class="field-canvas-tabs">
              <button class="field-canvas-tab ${this.activeView === 'atlas' ? 'active' : ''}" data-view="atlas">
                Data Atlas
              </button>
              <button class="field-canvas-tab ${this.activeView === 'builder' ? 'active' : ''}" data-view="builder">
                Screen Builder
              </button>
              <button class="field-canvas-tab ${this.activeView === 'matrix' ? 'active' : ''}" data-view="matrix">
                Field Matrix
              </button>
            </div>

            <div class="field-canvas-content">
              ${this.renderActiveView()}
            </div>

            <div class="field-canvas-footer">
              <div class="footer-info">
                ${this.pendingChanges.size > 0 ? `${this.pendingChanges.size} pending changes` : 'No changes'}
              </div>
              <div class="footer-actions">
                <button class="footer-btn secondary" data-action="reset-tab">Reset to Defaults</button>
                <button class="footer-btn secondary" data-action="close-canvas">Cancel</button>
                <button class="footer-btn primary" data-action="save-canvas">Save Changes</button>
              </div>
            </div>
          </div>
        </div>
      `;

      document.body.insertAdjacentHTML('beforeend', html);
      this.attachEventListeners();
    },

    /**
     * Render the active view content
     */
    renderActiveView() {
      switch (this.activeView) {
        case 'atlas':
          return this.renderDataAtlas();
        case 'builder':
          return this.renderScreenBuilder();
        case 'matrix':
          return this.renderFieldMatrix();
        default:
          return this.renderDataAtlas();
      }
    },

    /**
     * Render Data Atlas view - all fields overview
     */
    renderDataAtlas() {
      const fieldsByTable = FieldRegistry.getFieldsByTable();
      const tables = Object.keys(fieldsByTable).sort();
      const visibleFields = FieldPreferences.getVisibleFields(this.currentTab);

      return `
        <div class="field-canvas-view active" data-view="atlas">
          <div class="field-canvas-toolbar">
            <div class="field-canvas-search">
              <input type="text"
                     placeholder="Search fields by name or address..."
                     value="${Utils.escapeHtml(this.searchQuery)}"
                     data-action="search-fields">
            </div>
            <div class="field-canvas-filter">
              <select data-action="filter-table">
                <option value="all" ${this.filterTable === 'all' ? 'selected' : ''}>All Tables</option>
                ${tables.map(t => `
                  <option value="${Utils.escapeHtml(t)}" ${this.filterTable === t ? 'selected' : ''}>
                    ${Utils.escapeHtml(t)}
                  </option>
                `).join('')}
              </select>
              <select data-action="filter-tier">
                <option value="all" ${this.filterTier === 'all' ? 'selected' : ''}>All Tiers</option>
                <option value="1" ${this.filterTier === '1' ? 'selected' : ''}>Tier 1 (Semantic)</option>
                <option value="2" ${this.filterTier === '2' ? 'selected' : ''}>Tier 2 (Pattern)</option>
                <option value="3" ${this.filterTier === '3' ? 'selected' : ''}>Tier 3 (Raw)</option>
              </select>
            </div>
          </div>
          <div class="data-atlas-container">
            ${tables.map(tableName => this.renderTableGroup(tableName, fieldsByTable[tableName], visibleFields)).join('')}
          </div>
        </div>
      `;
    },

    /**
     * Render a table group in Data Atlas
     */
    renderTableGroup(tableName, fields, visibleFields) {
      // Apply filters
      let filteredFields = fields;

      if (this.filterTable !== 'all' && this.filterTable !== tableName) {
        return '';
      }

      if (this.filterTier !== 'all') {
        filteredFields = filteredFields.filter(f => f.tier === parseInt(this.filterTier));
      }

      if (this.searchQuery) {
        const q = this.searchQuery.toLowerCase();
        filteredFields = filteredFields.filter(f =>
          f.fieldName.toLowerCase().includes(q) ||
          f.tupleAddress.toLowerCase().includes(q) ||
          f.displayName.toLowerCase().includes(q)
        );
      }

      // Filter out structural fields unless searching
      if (!this.searchQuery) {
        filteredFields = filteredFields.filter(f => !f.isStructural);
      }

      if (filteredFields.length === 0) return '';

      return `
        <div class="data-atlas-table-group">
          <div class="data-atlas-table-header">
            <span class="data-atlas-table-name">${Utils.escapeHtml(tableName)}</span>
            <span class="data-atlas-table-count">${filteredFields.length} fields</span>
          </div>
          <div class="data-atlas-fields">
            ${filteredFields.map(field => this.renderAtlasField(field, visibleFields)).join('')}
          </div>
        </div>
      `;
    },

    /**
     * Render a single field card in Data Atlas
     */
    renderAtlasField(field, visibleFields) {
      const isVisible = visibleFields.length === 0 || visibleFields.includes(field.fieldName);
      const isHidden = FieldPreferences.isAlwaysHidden(this.currentTab, field.fieldName);

      // Get current tab placements
      const allTabs = Object.keys(CONFIG?.MAIN_TABS || {});

      return `
        <div class="field-atlas-card ${isHidden ? 'hidden-field' : ''}" data-field="${Utils.escapeHtml(field.fieldName)}">
          <div class="field-atlas-checkbox">
            <input type="checkbox"
                   ${isVisible && !isHidden ? 'checked' : ''}
                   ${isHidden ? 'disabled' : ''}
                   data-action="toggle-field-visibility"
                   data-field="${Utils.escapeHtml(field.fieldName)}"
                   title="${isHidden ? 'This field is always hidden' : 'Toggle visibility'}">
          </div>
          <div class="field-atlas-info">
            <div class="field-atlas-name">
              ${Utils.escapeHtml(field.displayName)}
              <span class="tier-badge tier-${field.tier}">Tier ${field.tier}</span>
            </div>
            <div class="field-atlas-address">${Utils.escapeHtml(field.tupleAddress)}</div>
            <div class="field-atlas-semantic">
              ${field.semanticAddress
                ? `<span class="semantic-group">${Utils.escapeHtml(field.semanticGroup)}</span> ${Utils.escapeHtml(field.semanticAddress)}`
                : `<span class="semantic-group">${Utils.escapeHtml(field.semanticGroup)}</span>`
              }
              ${field.dataType ? `<span style="color: var(--text-muted)">${Utils.escapeHtml(field.dataType)}</span>` : ''}
            </div>
          </div>
          <div class="field-atlas-placements">
            ${allTabs.slice(0, 4).map(tabId => {
              const tabConfig = CONFIG?.MAIN_TABS?.[tabId];
              const isOnTab = FieldPreferences.getVisibleFields(tabId).includes(field.fieldName) ||
                              (FieldPreferences.getVisibleFields(tabId).length === 0 &&
                               !FieldPreferences.isAlwaysHidden(tabId, field.fieldName));
              return `<span class="placement-badge ${isOnTab && tabId === this.currentTab ? 'active' : ''}"
                            title="${tabConfig?.label || tabId}">
                ${(tabConfig?.label || tabId).slice(0, 3)}
              </span>`;
            }).join('')}
          </div>
        </div>
      `;
    },

    /**
     * Render Screen Builder view - drag-drop zones
     */
    renderScreenBuilder() {
      const zones = ScreenZones.getZonesForTab(this.currentTab);
      const allFields = FieldRegistry.getAllFields().filter(f => !f.isStructural);
      const fieldsByGroup = this.groupFieldsBySemanticGroup(allFields);

      return `
        <div class="field-canvas-view active" data-view="builder">
          <div class="screen-builder-container">
            <div class="screen-builder-zones">
              <h3 style="margin-bottom: 16px; font-size: 14px; color: var(--text-secondary)">
                Drag fields to customize ${CONFIG?.MAIN_TABS?.[this.currentTab]?.label || this.currentTab} layout
              </h3>
              ${zones.map(zone => this.renderDropZone(zone)).join('')}
            </div>
            <div class="screen-builder-palette">
              <div class="palette-header">
                <div class="palette-title">Available Fields</div>
                <div class="palette-search">
                  <input type="text" placeholder="Search fields..." data-action="palette-search">
                </div>
              </div>
              <div class="palette-fields">
                ${Object.entries(fieldsByGroup).map(([group, fields]) => `
                  <div class="palette-group">
                    <div class="palette-group-header">${Utils.escapeHtml(group)}</div>
                    ${fields.map(field => this.renderPaletteField(field)).join('')}
                  </div>
                `).join('')}
              </div>
            </div>
          </div>
        </div>
      `;
    },

    /**
     * Render a drop zone
     */
    renderDropZone(zone) {
      const contents = this.getZoneContents(zone.id);

      return `
        <div class="drop-zone" data-zone="${zone.id}">
          <div class="drop-zone-header">
            <span class="drop-zone-title">
              <span class="zone-icon">${zone.icon}</span>
              ${Utils.escapeHtml(zone.label)}
            </span>
            <span class="drop-zone-count">${contents.length} fields</span>
          </div>
          <div class="drop-zone-content" data-zone="${zone.id}">
            ${contents.length === 0
              ? `<div class="drop-zone-empty">Drag fields here</div>`
              : contents.map(fieldName => {
                  const field = FieldRegistry.getField(fieldName);
                  if (!field) return '';
                  return `
                    <div class="field-chip" draggable="true" data-field="${Utils.escapeHtml(fieldName)}">
                      <span class="chip-name" title="${Utils.escapeHtml(field.tupleAddress)}">${Utils.escapeHtml(field.displayName)}</span>
                      <span class="chip-remove" data-action="remove-from-zone" data-field="${Utils.escapeHtml(fieldName)}" data-zone="${zone.id}">&times;</span>
                    </div>
                  `;
                }).join('')
            }
          </div>
        </div>
      `;
    },

    /**
     * Render a palette field
     */
    renderPaletteField(field) {
      const isInUse = this.isFieldInAnyZone(field.fieldName);

      return `
        <div class="palette-field ${isInUse ? 'in-use' : ''}"
             draggable="${!isInUse}"
             data-field="${Utils.escapeHtml(field.fieldName)}">
          <div class="palette-field-info">
            <div class="palette-field-name">${Utils.escapeHtml(field.displayName)}</div>
            <div class="palette-field-address">${Utils.escapeHtml(field.tupleAddress)}</div>
          </div>
        </div>
      `;
    },

    /**
     * Render Field Matrix view - spreadsheet-like
     */
    renderFieldMatrix() {
      const allFields = FieldRegistry.getAllFields().filter(f => !f.isStructural);
      const tabs = Object.keys(CONFIG?.MAIN_TABS || {});

      return `
        <div class="field-canvas-view active" data-view="matrix">
          <div class="field-canvas-toolbar">
            <div class="field-canvas-search">
              <input type="text" placeholder="Filter fields..." value="${Utils.escapeHtml(this.searchQuery)}" data-action="search-fields">
            </div>
          </div>
          <div class="field-matrix-container">
            <table class="field-matrix">
              <thead>
                <tr>
                  <th class="field-col">Field Address</th>
                  ${tabs.map(tabId => `
                    <th>${Utils.escapeHtml(CONFIG?.MAIN_TABS?.[tabId]?.label || tabId)}</th>
                  `).join('')}
                </tr>
              </thead>
              <tbody>
                ${allFields
                  .filter(f => !this.searchQuery ||
                    f.fieldName.toLowerCase().includes(this.searchQuery.toLowerCase()) ||
                    f.tupleAddress.toLowerCase().includes(this.searchQuery.toLowerCase()))
                  .slice(0, 100) // Limit for performance
                  .map(field => `
                    <tr>
                      <td class="field-col">
                        <strong>${Utils.escapeHtml(field.displayName)}</strong>
                        <span class="field-address">${Utils.escapeHtml(field.tupleAddress)}</span>
                      </td>
                      ${tabs.map(tabId => {
                        const visibleFields = FieldPreferences.getVisibleFields(tabId);
                        const isHidden = FieldPreferences.isAlwaysHidden(tabId, field.fieldName);
                        const isVisible = !isHidden && (visibleFields.length === 0 || visibleFields.includes(field.fieldName));

                        return `
                          <td class="screen-col">
                            <input type="checkbox"
                                   class="matrix-check"
                                   ${isVisible ? 'checked' : ''}
                                   ${isHidden ? 'disabled' : ''}
                                   data-action="matrix-toggle"
                                   data-field="${Utils.escapeHtml(field.fieldName)}"
                                   data-tab="${tabId}">
                          </td>
                        `;
                      }).join('')}
                    </tr>
                  `).join('')}
              </tbody>
            </table>
          </div>
        </div>
      `;
    },

    /**
     * Group fields by semantic group
     */
    groupFieldsBySemanticGroup(fields) {
      const groups = {};
      for (const field of fields) {
        const group = field.semanticGroup || 'Uncategorized';
        if (!groups[group]) groups[group] = [];
        groups[group].push(field);
      }

      // Sort groups by CONFIG.GROUP_ORDER
      const order = CONFIG?.GROUP_ORDER || Object.keys(groups);
      const sorted = {};
      for (const groupName of order) {
        if (groups[groupName]) {
          sorted[groupName] = groups[groupName];
        }
      }
      // Add any remaining groups
      for (const groupName of Object.keys(groups)) {
        if (!sorted[groupName]) {
          sorted[groupName] = groups[groupName];
        }
      }

      return sorted;
    },

    /**
     * Get zone contents (from pending changes or saved preferences)
     */
    getZoneContents(zoneId) {
      const key = `${this.currentTab}::${zoneId}`;
      if (this.pendingChanges.has(key)) {
        return this.pendingChanges.get(key);
      }
      return LayoutPreferences.getZoneContents(this.currentTab, zoneId);
    },

    /**
     * Set zone contents (to pending changes)
     */
    setZoneContents(zoneId, fieldNames) {
      const key = `${this.currentTab}::${zoneId}`;
      this.pendingChanges.set(key, [...fieldNames]);
    },

    /**
     * Check if field is in any zone of current tab
     */
    isFieldInAnyZone(fieldName) {
      const zones = ScreenZones.getZonesForTab(this.currentTab);
      for (const zone of zones) {
        const contents = this.getZoneContents(zone.id);
        if (contents.includes(fieldName)) return true;
      }
      return false;
    },

    /**
     * Attach event listeners
     */
    attachEventListeners() {
      const overlay = document.getElementById('field-canvas-overlay');
      if (!overlay) return;

      // Close button
      overlay.querySelectorAll('[data-action="close-canvas"]').forEach(btn => {
        btn.addEventListener('click', () => this.close());
      });

      // Save button
      overlay.querySelector('[data-action="save-canvas"]')?.addEventListener('click', () => {
        this.save();
      });

      // Reset button
      overlay.querySelector('[data-action="reset-tab"]')?.addEventListener('click', () => {
        LayoutPreferences.resetTab(this.currentTab);
        FieldPreferences.setVisibleFields(this.currentTab,
          CONFIG?.MAIN_TABS?.[this.currentTab]?.defaultFields || []);
        this.pendingChanges.clear();
        this.render();
      });

      // View tabs
      overlay.querySelectorAll('.field-canvas-tab').forEach(tab => {
        tab.addEventListener('click', (e) => {
          this.activeView = e.target.dataset.view;
          this.render();
        });
      });

      // Search input
      overlay.querySelectorAll('[data-action="search-fields"]').forEach(input => {
        input.addEventListener('input', (e) => {
          this.searchQuery = e.target.value;
          this.render();
        });
      });

      // Filter selects
      overlay.querySelector('[data-action="filter-table"]')?.addEventListener('change', (e) => {
        this.filterTable = e.target.value;
        this.render();
      });

      overlay.querySelector('[data-action="filter-tier"]')?.addEventListener('change', (e) => {
        this.filterTier = e.target.value;
        this.render();
      });

      // Field visibility toggles in Atlas view
      overlay.querySelectorAll('[data-action="toggle-field-visibility"]').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
          const fieldName = e.target.dataset.field;
          const visible = e.target.checked;

          // Update via FieldPreferences
          const currentVisible = FieldPreferences.getVisibleFields(this.currentTab);

          if (currentVisible.length === 0) {
            // First customization - start with all non-hidden fields
            const allFields = FieldRegistry.getAllFields()
              .filter(f => !f.isStructural && !FieldPreferences.isAlwaysHidden(this.currentTab, f.fieldName))
              .map(f => f.fieldName);

            if (!visible) {
              // Uncheck = remove from all
              const newVisible = allFields.filter(f => f !== fieldName);
              FieldPreferences.setVisibleFields(this.currentTab, newVisible);
            }
          } else {
            FieldPreferences.toggleField(this.currentTab, fieldName, visible);
          }

          // Re-render to update badges
          this.render();
        });
      });

      // Matrix checkboxes
      overlay.querySelectorAll('[data-action="matrix-toggle"]').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
          const fieldName = e.target.dataset.field;
          const tabId = e.target.dataset.tab;
          const visible = e.target.checked;

          const currentVisible = FieldPreferences.getVisibleFields(tabId);

          if (currentVisible.length === 0) {
            const allFields = FieldRegistry.getAllFields()
              .filter(f => !f.isStructural && !FieldPreferences.isAlwaysHidden(tabId, f.fieldName))
              .map(f => f.fieldName);

            if (!visible) {
              const newVisible = allFields.filter(f => f !== fieldName);
              FieldPreferences.setVisibleFields(tabId, newVisible);
            }
          } else {
            FieldPreferences.toggleField(tabId, fieldName, visible);
          }
        });
      });

      // Remove from zone buttons
      overlay.querySelectorAll('[data-action="remove-from-zone"]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const fieldName = e.target.dataset.field;
          const zoneId = e.target.dataset.zone;

          const current = this.getZoneContents(zoneId);
          const newContents = current.filter(f => f !== fieldName);
          this.setZoneContents(zoneId, newContents);
          this.render();
        });
      });

      // Drag and drop for Screen Builder
      this.setupDragAndDrop(overlay);

      // Close on overlay click (outside modal)
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) {
          this.close();
        }
      });

      // Close on Escape
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && this.isOpen) {
          this.close();
        }
      });
    },

    /**
     * Setup drag and drop for Screen Builder
     */
    setupDragAndDrop(overlay) {
      // Draggable fields
      overlay.querySelectorAll('[draggable="true"]').forEach(el => {
        el.addEventListener('dragstart', (e) => {
          this.draggedField = e.target.dataset.field;
          e.target.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
        });

        el.addEventListener('dragend', (e) => {
          e.target.classList.remove('dragging');
          this.draggedField = null;
        });
      });

      // Drop zones
      overlay.querySelectorAll('.drop-zone-content').forEach(zone => {
        zone.addEventListener('dragover', (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          zone.closest('.drop-zone').classList.add('drag-over');
        });

        zone.addEventListener('dragleave', (e) => {
          zone.closest('.drop-zone').classList.remove('drag-over');
        });

        zone.addEventListener('drop', (e) => {
          e.preventDefault();
          zone.closest('.drop-zone').classList.remove('drag-over');

          if (this.draggedField) {
            const zoneId = zone.dataset.zone;
            const current = this.getZoneContents(zoneId);

            // Remove from other zones first
            const zones = ScreenZones.getZonesForTab(this.currentTab);
            for (const z of zones) {
              if (z.id !== zoneId) {
                const zContents = this.getZoneContents(z.id);
                if (zContents.includes(this.draggedField)) {
                  this.setZoneContents(z.id, zContents.filter(f => f !== this.draggedField));
                }
              }
            }

            // Add to this zone if not already there
            if (!current.includes(this.draggedField)) {
              current.push(this.draggedField);
              this.setZoneContents(zoneId, current);
            }

            this.render();
          }
        });
      });
    }
  };

  // Make FieldCanvas globally accessible
  window.FieldCanvas = FieldCanvas;

  // ==========================================================================
  // DATA TRANSFORMER
  // Converts flat API array format to normalized clientInfo/cases structure
  // ==========================================================================

  const DataTransformer = {
    /**
     * Transform raw API response (flat array of case records) into normalized format
     * @param {Array|Object} rawData - Raw webhook response
     * @returns {Object} Normalized { clientInfo, cases, events, applications, hearings } structure
     */
    transform(rawData) {
      console.log('[DataTransformer] Raw data type:', typeof rawData, Array.isArray(rawData) ? 'array' : '');

      // Handle response with schema included: { schema: [...], data: [...] }
      if (rawData && rawData.schema && Array.isArray(rawData.schema)) {
        console.log('[DataTransformer] Schema detected in response');
        SchemaProcessor.init(rawData.schema);
        rawData = rawData.data || rawData.records || [];
      }

      // NEW: Handle 5-bucket master record format from n8n
      // Format: { _meta, client, cases, applications, hearings, events }
      if (rawData && this.isMasterRecordFormat(rawData)) {
        console.log('[DataTransformer] Detected 5-bucket master record format');
        return this.transformMasterRecord(rawData);
      }

      // Handle n8n webhook format: { records: [...] }
      if (rawData && rawData.records && Array.isArray(rawData.records)) {
        console.log('[DataTransformer] Detected { records: [...] } format with', rawData.records.length, 'records');
        rawData = rawData.records;
      }

      // Handle already-normalized data with potential schema
      if (rawData && rawData.clientInfo) {
        // Check if schema is embedded
        if (rawData.schema) {
          SchemaProcessor.init(rawData.schema);
        }
        return rawData;
      }

      // Handle flat array of records (actual Airtable format)
      if (!Array.isArray(rawData) || rawData.length === 0) {
        console.warn('[DataTransformer] Empty or invalid data received:', rawData);
        return { clientInfo: { fields: {} }, cases: [], events: [], applications: [], hearings: [] };
      }

      // Filter out empty objects from the array
      const records = rawData.filter(record =>
        record && typeof record === 'object' && Object.keys(record).length > 0
      );

      if (records.length === 0) {
        console.warn('[DataTransformer] No valid records after filtering');
        return { clientInfo: { fields: {} }, cases: [] };
      }

      // Separate records by table type
      const { clientInfoRecord, caseRecords, eventRecords, applicationRecords } = this.separateRecordTypes(records);

      // Extract client fields - try from Client Info record first, then fall back to Case record
      const clientFields = clientInfoRecord
        ? this.extractClientFieldsFromClientInfo(clientInfoRecord)
        : this.extractClientFields(caseRecords[0] || {});

      // Transform case records
      const transformedCases = caseRecords.map((record, index) => this.transformCase(record, index));

      // Transform event records
      const events = eventRecords.map((record, index) => this.transformEvent(record, index));

      // Transform application records
      const applications = applicationRecords.map((record, index) => this.transformApplication(record, index));

      // Deduplicate cases by recordId AND caseIdentifier
      const seenRecordIds = new Set();
      const seenCaseIdentifiers = new Set();
      const cases = transformedCases.filter(caseRecord => {
        if (caseRecord.recordId && seenRecordIds.has(caseRecord.recordId)) {
          return false;
        }
        const isGenericLabel = /^Case \d+$/.test(caseRecord.caseIdentifier);
        if (!isGenericLabel && seenCaseIdentifiers.has(caseRecord.caseIdentifier)) {
          return false;
        }
        if (caseRecord.recordId) seenRecordIds.add(caseRecord.recordId);
        seenCaseIdentifiers.add(caseRecord.caseIdentifier);
        return true;
      });

      console.log(`[DataTransformer] Result: ${cases.length} cases, ${events.length} events, ${applications.length} applications`);

      return {
        clientInfo: {
          recordId: clientInfoRecord?.id ||
                    clientInfoRecord?.recordId ||
                    this.unwrapValue(caseRecords[0]?.['Client_ID_Airtable']) ||
                    caseRecords[0]?.id,
          fields: clientFields
        },
        cases,
        events,
        applications
      };
    },

    /**
     * Separate records by source table type
     * Uses _sourceTable field when available, falls back to field-based heuristics
     */
    separateRecordTypes(records) {
      let clientInfoRecord = null;
      const caseRecords = [];
      const eventRecords = [];
      const applicationRecords = [];

      for (const record of records) {
        const sourceTable = record._sourceTable;

        // Primary detection: use _sourceTable field if available
        if (sourceTable) {
          const tableLower = sourceTable.toLowerCase();

          if (tableLower === 'client info' || (tableLower.includes('client info') && !tableLower.includes('case'))) {
            clientInfoRecord = record;
            console.log(`[DataTransformer] Client Info record via _sourceTable: ${sourceTable}`);
            continue;
          }

          if (tableLower === 'events' || tableLower.includes('event')) {
            eventRecords.push(record);
            continue;
          }

          if (tableLower === 'applications' || tableLower.includes('application')) {
            applicationRecords.push(record);
            continue;
          }

          if (tableLower.includes('case master') || tableLower === 'case master view') {
            caseRecords.push(record);
            continue;
          }

          // Any other table - treat as case record by default
          caseRecords.push(record);
        } else {
          // Fallback: field-based heuristics for older response formats
          const clientInfoIndicators = [
            'Full Client Name', 'Full_Name_Normal_Pretty', 'Client Name', 'Address Line 1',
            'City', 'Zip (5)', 'PPID', 'Softr Client Page', 'Gmail_Search_Terms',
            'Box_Folder_ID', 'Client Details Page', 'airtable_client_info_id'
          ];
          const caseIndicators = [
            'Case Notes', 'Activity', 'Details', 'Matter_Flatpack',
            'Case Master View Record ID', 'Appeal Engagement Deadline'
          ];

          const hasClientInfoFields = clientInfoIndicators.some(f => record[f] !== undefined);
          const hasCaseFields = caseIndicators.some(f => record[f] !== undefined);

          if (hasClientInfoFields && !hasCaseFields) {
            clientInfoRecord = record;
            console.log('[DataTransformer] Client Info record via field heuristics');
            continue;
          }

          // Default: treat as Case Master View record
          caseRecords.push(record);
        }
      }

      console.log(`[DataTransformer] Separated records - clientInfo: ${clientInfoRecord ? 'yes' : 'no'}, cases: ${caseRecords.length}, events: ${eventRecords.length}, applications: ${applicationRecords.length}`);
      return { clientInfoRecord, caseRecords, eventRecords, applicationRecords };
    },

    /**
     * Extract client fields from a dedicated Client Info record
     * Maps field names from Client Info table format to expected format
     */
    extractClientFieldsFromClientInfo(record) {
      // Map Client Info table field names to standard display names
      const fieldMappings = {
        'Full Client Name': 'Client Name',
        'Full_Name_Normal_Pretty': 'Client Name',
        'Client Name': 'Client Name',
        'First Name': 'First Name',
        'Family Name': 'Family Name',
        'Middle Name': 'Middle Name',
        'A#': 'A#',
        'DOB': 'DOB',
        'Age': 'Age',
        'Country': 'Country',
        'Phone Number': 'Phone Number',
        'Phone Reformat 3 (xxx) xxx-xxxx': 'Phone Number',
        'Client Email': 'Client Email',
        'Address Formula': 'Address',
        'Address': 'Address',
        'Gender': 'Gender',
        'Pronouns': 'Pronouns',
        'Detained': 'Detained',
        'Detainment Status / Location': 'Detention Location'
      };

      const fields = {};

      // First, directly check for 'Client Name' field from Client Info record
      if (record['Client Name'] !== undefined && record['Client Name'] !== null && record['Client Name'] !== '') {
        const normalizedName = this.normalizeValue(record['Client Name'], 'Client Name');
        if (normalizedName !== null) {
          fields['Client Name'] = normalizedName;
          console.log('[DataTransformer] Found Client Name from Client Info:', normalizedName);
        }
      }

      // Then process other field mappings
      for (const [sourceField, targetField] of Object.entries(fieldMappings)) {
        if (record[sourceField] !== undefined && !fields[targetField]) {
          const value = this.normalizeValue(record[sourceField], sourceField);
          if (value !== null) {
            fields[targetField] = value;
          }
        }
      }

      // Compose Client Name from First Name + Family Name if not already set
      if (!fields['Client Name']) {
        const firstName = fields['First Name'] || '';
        const familyName = fields['Family Name'] || '';
        const middleName = fields['Middle Name'] || '';
        const nameParts = [firstName, middleName, familyName].filter(p => p);
        if (nameParts.length > 0) {
          fields['Client Name'] = nameParts.join(' ');
          console.log('[DataTransformer] Composed Client Name from parts:', fields['Client Name']);
        }
      }

      console.log('[DataTransformer] Extracted client fields:', Object.keys(fields));
      return fields;
    },

    /**
     * Extract client-level fields from a record
     */
    extractClientFields(record) {
      const clientFieldNames = [
        'Client Name', 'Full_Name_Normal_Pretty', 'First Name', 'Family Name', 'Middle Name',
        'A#', 'DOB', 'Age', 'Country', 'Phone Number', 'Client Email',
        'Address', 'Gender', 'Pronouns'
      ];

      const fields = {};
      for (const fieldName of clientFieldNames) {
        if (record[fieldName] !== undefined) {
          const value = this.normalizeValue(record[fieldName], fieldName);
          if (value !== null) {
            // Map Full_Name_Normal_Pretty to Client Name
            const targetField = fieldName === 'Full_Name_Normal_Pretty' ? 'Client Name' : fieldName;
            if (!fields[targetField]) {
              fields[targetField] = value;
            }
          }
        }
      }

      // Compose Client Name from First Name + Family Name if not already set
      if (!fields['Client Name']) {
        const firstName = fields['First Name'] || '';
        const familyName = fields['Family Name'] || '';
        const middleName = fields['Middle Name'] || '';
        const nameParts = [firstName, middleName, familyName].filter(p => p);
        if (nameParts.length > 0) {
          fields['Client Name'] = nameParts.join(' ');
        }
      }

      return fields;
    },

    /**
     * Transform a single case record
     */
    transformCase(record, index) {
      const caseIdentifier = this.deriveCaseIdentifier(record, index);
      const fields = {};

      // Client fields to exclude from case
      const clientOnlyFields = new Set([
        'Client Name', 'First Name', 'Family Name', 'Middle Name',
        'A#', 'DOB', 'Age', 'Country', 'Phone Number', 'Client Email',
        'Address', 'Client_ID_Airtable', 'Edit Client Info', 'Gender', 'Pronouns'
      ]);

      for (const [fieldName, rawValue] of Object.entries(record)) {
        // Skip client-only fields (they go in clientInfo)
        if (clientOnlyFields.has(fieldName)) continue;

        // Skip metadata fields
        if (fieldName === 'id' || fieldName === 'createdTime') continue;

        const value = this.normalizeValue(rawValue, fieldName);
        if (value !== null) {
          fields[fieldName] = value;
        }
      }

      return {
        recordId: record.id || record['Case Master View Record ID'] || `case-${index}`,
        caseIdentifier,
        fields
      };
    },

    /**
     * Transform a single event record
     */
    transformEvent(record, index) {
      const fields = {};
      const skipFields = new Set(['id', 'createdTime', '_sourceTable', 'Client Name']);

      for (const [fieldName, rawValue] of Object.entries(record)) {
        if (skipFields.has(fieldName)) continue;
        const value = this.normalizeValue(rawValue, fieldName);
        if (value !== null) {
          fields[fieldName] = value;
        }
      }

      return {
        recordId: record.id || `event-${index}`,
        title: record.Description || record.summary || `Event ${index + 1}`,
        startDate: record['Start Date'] || record.start?.dateTime || record.start?.date,
        endDate: record['End Date'] || record.end?.dateTime || record.end?.date,
        location: record.Location || record.location,
        fields
      };
    },

    /**
     * Transform a single application record
     */
    transformApplication(record, index) {
      const fields = {};
      const skipFields = new Set(['id', 'createdTime', '_sourceTable', 'Client Name']);

      for (const [fieldName, rawValue] of Object.entries(record)) {
        if (skipFields.has(fieldName)) continue;
        const value = this.normalizeValue(rawValue, fieldName);
        if (value !== null) {
          fields[fieldName] = value;
        }
      }

      return {
        recordId: record.id || `app-${index}`,
        type: record['Current USCIS application'] || record.Description || `Application ${index + 1}`,
        caseId: record['Case Master View ID'],
        fields
      };
    },

    /**
     * Derive a human-readable case identifier
     */
    deriveCaseIdentifier(record, index) {
      // Try Description field first (e.g., "EAD (0)", "Defensive Asylum (1000)")
      if (record.Description) {
        return this.cleanCaseDescription(record.Description);
      }

      // Try Matter_Flatpack JSON
      if (record.Matter_Flatpack) {
        try {
          const matter = typeof record.Matter_Flatpack === 'string'
            ? JSON.parse(record.Matter_Flatpack)
            : record.Matter_Flatpack;
          if (matter.description) {
            return this.cleanCaseDescription(matter.description);
          }
        } catch (e) { /* ignore parse errors */ }
      }

      // Fallback to generic label
      return `Case ${index + 1}`;
    },

    /**
     * Clean up case description for display
     */
    cleanCaseDescription(desc) {
      // Remove parenthetical numbers like "(0)", "(1000)"
      return desc.replace(/\s*\(\d+\)\s*$/, '').trim() || desc;
    },

    /**
     * Normalize a field value - unwrap arrays, filter errors, extract buttons
     */
    normalizeValue(rawValue, fieldName) {
      // Handle null/undefined
      if (rawValue === null || rawValue === undefined || rawValue === '') {
        return null;
      }

      // Handle booleans
      if (typeof rawValue === 'boolean') {
        return rawValue ? 'Yes' : 'No';
      }

      // Handle error objects
      if (typeof rawValue === 'object' && rawValue !== null && !Array.isArray(rawValue)) {
        if (rawValue.error || rawValue.specialValue === 'NaN') {
          return null; // Filter out errors and NaN
        }

        // Handle button objects { label, url }
        if (rawValue.label !== undefined && rawValue.url !== undefined) {
          // Only keep buttons with actual URLs
          if (rawValue.url && rawValue.url.trim()) {
            return { type: 'button', label: rawValue.label, url: rawValue.url };
          }
          return null;
        }

        // Handle user objects { id, email, name }
        if (rawValue.id && rawValue.name && rawValue.email) {
          return rawValue.name;
        }

        // Handle attachment objects { id, url, filename, type }
        if (rawValue.url && rawValue.filename) {
          return {
            type: 'attachment',
            label: rawValue.filename,
            url: rawValue.url,
            fileType: rawValue.type || 'file'
          };
        }
      }

      // Handle arrays
      if (Array.isArray(rawValue)) {
        // Filter out null, undefined, empty strings
        const filtered = rawValue.filter(v => v !== null && v !== undefined && v !== '');
        if (filtered.length === 0) return null;

        // Check if it's an array of attachments
        if (filtered[0] && typeof filtered[0] === 'object' && filtered[0].url && filtered[0].filename) {
          // Return first attachment as button-like object
          return {
            type: 'attachment',
            label: filtered[0].filename,
            url: filtered[0].url,
            fileType: filtered[0].type || 'file'
          };
        }

        // Single element - recursively normalize
        if (filtered.length === 1) {
          return this.normalizeValue(filtered[0], fieldName);
        }

        // Multi-element arrays: join if all strings/numbers (excluding record IDs)
        if (filtered.every(v => typeof v === 'string' || typeof v === 'number')) {
          // Skip if they look like record IDs
          if (filtered.every(v => /^rec[a-zA-Z0-9]+$/.test(String(v)))) {
            return null; // Don't display raw record IDs
          }
          return filtered.join(', ');
        }

        // Otherwise return as-is for complex arrays
        return filtered;
      }

      return rawValue;
    },

    /**
     * Unwrap a value that might be array-wrapped
     */
    unwrapValue(value) {
      if (Array.isArray(value) && value.length > 0) {
        return value[0];
      }
      return value;
    },

    /**
     * Detect if data is in the new 5-bucket master record format
     * Format: { _meta?, client, cases, applications?, hearings?, events? }
     */
    isMasterRecordFormat(data) {
      if (!data || typeof data !== 'object' || Array.isArray(data)) {
        return false;
      }
      // Must have client (object) and cases (array) at minimum
      const hasClient = data.client && typeof data.client === 'object' && !Array.isArray(data.client);
      const hasCases = Array.isArray(data.cases);
      // Also check for _meta as a strong indicator
      const hasMeta = data._meta && typeof data._meta === 'object';

      return (hasClient && hasCases) || hasMeta;
    },

    /**
     * Transform 5-bucket master record format to normalized widget format
     * Input: { _meta, client, cases, applications, hearings, events }
     * Output: { clientInfo, cases, events, applications, hearings }
     */
    transformMasterRecord(masterRecord) {
      console.log('[DataTransformer] Transforming master record format');
      console.log('[DataTransformer] Record counts:', masterRecord._meta?.recordCounts || 'no metadata');

      // Extract client fields from client bucket
      const clientFields = this.transformMasterClient(masterRecord.client);

      // Transform cases from cases bucket
      const cases = (masterRecord.cases || []).map((record, index) =>
        this.transformMasterCase(record, index)
      );

      // Transform applications from applications bucket
      const applications = (masterRecord.applications || []).map((record, index) =>
        this.transformMasterApplication(record, index)
      );

      // Transform hearings from hearings bucket (Google Calendar - Hearings)
      const hearings = (masterRecord.hearings || []).map((record, index) =>
        this.transformMasterCalendarEvent(record, index, 'hearing')
      );

      // Transform events from events bucket (Google Calendar - Events)
      const events = (masterRecord.events || []).map((record, index) =>
        this.transformMasterCalendarEvent(record, index, 'general')
      );

      const result = {
        clientInfo: {
          recordId: masterRecord.client?._recordId || masterRecord.client?.id,
          fields: clientFields
        },
        cases,
        applications,
        hearings,
        events
      };

      console.log(`[DataTransformer] Master record result: clientInfo=${Object.keys(clientFields).length} fields, cases=${cases.length}, applications=${applications.length}, hearings=${hearings.length}, events=${events.length}`);

      return result;
    },

    /**
     * Transform client bucket fields to standard field format
     */
    transformMasterClient(clientRecord) {
      if (!clientRecord) return {};

      const fields = {};

      // Field name mappings from new schema to widget expected names
      const fieldMappings = {
        'Client Name': 'Client Name',
        'First Name': 'First Name',
        'Last Name': 'Family Name',
        'A#': 'A#',
        'DOB': 'DOB',
        'Country of Origin': 'Country',
        'Phone': 'Phone Number',
        'Email': 'Client Email',
        'Address': 'Address',
        'Emergency Contact': 'Emergency Contact',
        'Gender': 'Gender',
        'Pronouns': 'Pronouns'
      };

      for (const [sourceField, targetField] of Object.entries(fieldMappings)) {
        if (clientRecord[sourceField] !== undefined && clientRecord[sourceField] !== null) {
          const value = this.normalizeValue(clientRecord[sourceField], sourceField);
          if (value !== null) {
            fields[targetField] = value;
          }
        }
      }

      // Also include any other fields not in the mapping (preserve unknown fields)
      for (const [key, value] of Object.entries(clientRecord)) {
        if (key.startsWith('_')) continue; // Skip internal fields
        if (key === 'id') continue;
        if (!Object.keys(fieldMappings).includes(key) && !Object.values(fieldMappings).includes(key)) {
          const normalized = this.normalizeValue(value, key);
          if (normalized !== null && !fields[key]) {
            fields[key] = normalized;
          }
        }
      }

      // Compose Client Name from First Name + Last Name if not already set
      if (!fields['Client Name']) {
        const firstName = fields['First Name'] || '';
        const familyName = fields['Family Name'] || '';
        const nameParts = [firstName, familyName].filter(p => p);
        if (nameParts.length > 0) {
          fields['Client Name'] = nameParts.join(' ');
          console.log('[DataTransformer] Composed Client Name from parts:', fields['Client Name']);
        }
      }

      return fields;
    },

    /**
     * Transform a case record from the cases bucket
     */
    transformMasterCase(record, index) {
      const fields = {};
      const skipFields = new Set(['_recordId', 'id', 'Client_ID_Airtable']);

      // Field mappings for case fields
      const fieldMappings = {
        'Matter Type': 'Description',
        'Case Status': 'File Case Status',
        'Court': 'Court/Office',
        'Next Hearing': 'Hearing Date/Time',
        'Filing Deadline': 'Pleadings Due Date',
        'Case Number': 'Case Number'
      };

      for (const [sourceField, targetField] of Object.entries(fieldMappings)) {
        if (record[sourceField] !== undefined) {
          const value = this.normalizeValue(record[sourceField], sourceField);
          if (value !== null) {
            fields[targetField] = value;
          }
        }
      }

      // Copy remaining fields
      for (const [key, value] of Object.entries(record)) {
        if (skipFields.has(key)) continue;
        if (Object.keys(fieldMappings).includes(key)) continue;

        const normalized = this.normalizeValue(value, key);
        if (normalized !== null && !fields[key]) {
          fields[key] = normalized;
        }
      }

      const caseIdentifier = record['Matter Type']
        ? this.cleanCaseDescription(record['Matter Type'])
        : (record.Description ? this.cleanCaseDescription(record.Description) : `Case ${index + 1}`);

      return {
        recordId: record._recordId || record.id || `case-${index}`,
        caseIdentifier,
        fields
      };
    },

    /**
     * Transform an application record from the applications bucket
     */
    transformMasterApplication(record, index) {
      const fields = {};
      const skipFields = new Set(['_recordId', '_parentCaseId', 'id', 'Case Master']);

      for (const [key, value] of Object.entries(record)) {
        if (skipFields.has(key)) continue;

        const normalized = this.normalizeValue(value, key);
        if (normalized !== null) {
          fields[key] = normalized;
        }
      }

      return {
        recordId: record._recordId || record.id || `app-${index}`,
        type: record['Application Type'] || record['Form Number'] || `Application ${index + 1}`,
        caseId: record._parentCaseId || (record['Case Master'] ? record['Case Master'][0] : null),
        fields
      };
    },

    /**
     * Transform a calendar event from hearings or events bucket
     * Handles the normalized calendar event format from n8n
     */
    transformMasterCalendarEvent(record, index, calendarType) {
      const fields = {};
      const skipFields = new Set(['_id', '_calendarType']);

      // Map normalized calendar fields to display fields
      const fieldMappings = {
        'title': 'Event Name',
        'description': 'Description',
        'location': 'Location',
        'startDateTime': 'Start Date',
        'endDateTime': 'End Date',
        'htmlLink': 'Calendar Link',
        'meetLink': 'Meeting Link',
        'status': 'Status'
      };

      for (const [sourceField, targetField] of Object.entries(fieldMappings)) {
        if (record[sourceField] !== undefined && record[sourceField] !== null) {
          fields[targetField] = record[sourceField];
        }
      }

      // Handle attendees
      if (record.attendees && Array.isArray(record.attendees) && record.attendees.length > 0) {
        fields['Attendees'] = record.attendees.map(a => a.name || a.email).join(', ');
      }

      // Copy any other non-internal fields
      for (const [key, value] of Object.entries(record)) {
        if (skipFields.has(key)) continue;
        if (Object.keys(fieldMappings).includes(key)) continue;
        if (key === 'attendees' || key === 'isAllDay' || key === 'created' || key === 'updated') continue;

        const normalized = this.normalizeValue(value, key);
        if (normalized !== null && !fields[key]) {
          fields[key] = normalized;
        }
      }

      return {
        recordId: record._id || `${calendarType}-${index}`,
        title: record.title || `Event ${index + 1}`,
        startDate: record.startDateTime,
        endDate: record.endDateTime,
        location: record.location,
        isAllDay: record.isAllDay || false,
        calendarType: record._calendarType || calendarType,
        fields
      };
    }
  };

  // ==========================================================================
  // UTILITIES
  // ==========================================================================

  // Store recordId received via postMessage (for iframe embedding)
  let postMessageRecordId = null;

  // Listen for postMessage from parent window (for iframe embedding)
  window.addEventListener('message', (event) => {
    // Accept messages with recordId
    if (event.data && event.data.type === 'recordId' && event.data.recordId) {
      console.log('[ClientGlance] Received recordId via postMessage:', event.data.recordId);
      postMessageRecordId = event.data.recordId;

      // If widget already showed "No Record ID" error, re-initialize
      const container = document.getElementById('app');
      if (container && container.querySelector('.error')) {
        init();
      }
    }
  });

  const Utils = {
    // Get recordId from URL params (Softr passes this) or postMessage
    getRecordId() {
      // First, check if we received recordId via postMessage
      if (postMessageRecordId) {
        return postMessageRecordId;
      }

      try {
        const params = new URLSearchParams(window.location.search);
        return params.get('recordId') || params.get('record_id') || params.get('id');
      } catch (e) {
        // Handle cross-origin iframe SecurityError
        console.warn('[ClientGlance] Cannot access window.location (cross-origin iframe):', e.message);
        return null;
      }
    },

    // Format date
    formatDate(value, includeTime = false) {
      try {
        const date = new Date(value);
        if (isNaN(date.getTime())) return value;
        
        const options = includeTime 
          ? CONFIG?.DISPLAY?.dateTimeFormat || { year: 'numeric', month: 'short', day: 'numeric', hour: 'numeric', minute: '2-digit' }
          : CONFIG?.DISPLAY?.dateFormat || { year: 'numeric', month: 'short', day: 'numeric' };
        
        return date.toLocaleDateString('en-US', options);
      } catch {
        return value;
      }
    },

    // Format phone
    formatPhone(value) {
      const cleaned = String(value).replace(/\D/g, '');
      if (cleaned.length === 10) {
        return `(${cleaned.slice(0,3)}) ${cleaned.slice(3,6)}-${cleaned.slice(6)}`;
      }
      return value;
    },

    // Humanize field name
    humanizeFieldName(name) {
      return name
        .replace(/([A-Z])/g, ' $1')
        .replace(/_/g, ' ')
        .replace(/\s+/g, ' ')
        .trim()
        .replace(/^./, s => s.toUpperCase());
    },

    // Apply template with value
    applyTemplate(template, value, dataType) {
      let formattedValue = value;
      
      // Handle template format specifiers
      if (template.includes('{value:date}')) {
        formattedValue = this.formatDate(value);
        return template.replace('{value:date}', formattedValue);
      }
      if (template.includes('{value:datetime}')) {
        formattedValue = this.formatDate(value, true);
        return template.replace('{value:datetime}', formattedValue);
      }
      if (template.includes('{value:phone}')) {
        formattedValue = this.formatPhone(value);
        return template.replace('{value:phone}', formattedValue);
      }
      if (template.includes('{value:lowercase}')) {
        formattedValue = String(value).toLowerCase();
        return template.replace('{value:lowercase}', formattedValue);
      }
      
      return template.replace('{value}', value);
    },

    // Infer data type from value and optionally schema
    inferDataType(value, fieldName = null) {
      // First, try schema-based detection
      if (fieldName && SchemaProcessor.hasSchema()) {
        const schemaType = SchemaProcessor.getDisplayType(fieldName, value);
        if (schemaType) return schemaType;
      }

      // Fall back to pattern-based detection
      if (!value || typeof value !== 'string') return null;

      const patterns = CONFIG?.DATA_TYPE_PATTERNS || [];
      for (const { type, pattern, minLength } of patterns) {
        if (pattern.test(value)) {
          if (minLength && value.length < minLength) continue;
          return type;
        }
      }
      return null;
    },

    // Format value by inferred type
    formatByType(value, type) {
      switch (type) {
        case 'date': return this.formatDate(value);
        case 'datetime': return this.formatDate(value, true);
        case 'phone': return this.formatPhone(value);
        case 'boolean': return String(value).toLowerCase() === 'true' || String(value).toLowerCase() === 'yes' ? 'Yes' : 'No';
        case 'url': return value;
        default: return value;
      }
    },

    // Check if field should be hidden
    isHiddenField(fieldName) {
      // Check schema-based hiding first
      if (SchemaProcessor.hasSchema() && SchemaProcessor.shouldHideField(fieldName)) {
        return true;
      }

      const hiddenPatterns = CONFIG?.DISPLAY?.hiddenFields || [];
      return hiddenPatterns.some(pattern => {
        if (pattern instanceof RegExp) return pattern.test(fieldName);
        return fieldName === pattern;
      });
    },

    // Find group by pattern matching (with schema support)
    findGroupByPattern(fieldName) {
      // First, try schema-based grouping
      if (SchemaProcessor.hasSchema()) {
        const fieldType = SchemaProcessor.getFieldType(fieldName);
        const schemaGroup = SchemaProcessor.inferGroup(fieldName, fieldType);
        if (schemaGroup) return schemaGroup;
      }

      // Fall back to config patterns
      const patterns = CONFIG?.FIELD_GROUP_PATTERNS || [];
      for (const { group, pattern } of patterns) {
        if (pattern.test(fieldName)) return group;
      }
      return null;
    },

    // Escape HTML
    escapeHtml(str) {
      const div = document.createElement('div');
      div.textContent = str;
      return div.innerHTML;
    }
  };

  // ==========================================================================
  // DATA PROCESSOR
  // ==========================================================================

  const DataProcessor = {
    // Pronoun context for narrative composition
    pronounContext: {
      subject: 'They',      // He/She/They
      object: 'them',       // him/her/them
      possessive: 'their',  // his/her/their
      reflexive: 'themselves' // himself/herself/themselves
    },

    /**
     * Set pronouns based on client data
     */
    setPronouns(clientFields) {
      const gender = clientFields?.Gender?.toLowerCase?.();
      const pronounsField = clientFields?.Pronouns?.toLowerCase?.();

      // Check explicit pronouns field first
      if (pronounsField) {
        if (pronounsField.includes('she') || pronounsField.includes('her')) {
          this.pronounContext = { subject: 'She', object: 'her', possessive: 'her', reflexive: 'herself' };
        } else if (pronounsField.includes('he') || pronounsField.includes('him')) {
          this.pronounContext = { subject: 'He', object: 'him', possessive: 'his', reflexive: 'himself' };
        } else {
          // Default to They for they/them or unknown
          this.pronounContext = { subject: 'They', object: 'them', possessive: 'their', reflexive: 'themselves' };
        }
        return;
      }

      // Fall back to gender field
      if (gender === 'female' || gender === 'f') {
        this.pronounContext = { subject: 'She', object: 'her', possessive: 'her', reflexive: 'herself' };
      } else if (gender === 'male' || gender === 'm') {
        this.pronounContext = { subject: 'He', object: 'him', possessive: 'his', reflexive: 'himself' };
      } else {
        // Default to gender-neutral
        this.pronounContext = { subject: 'They', object: 'them', possessive: 'their', reflexive: 'themselves' };
      }
    },

    // Process raw webhook response into tiered fields
    processFields(rawData) {
      // Transform flat array format to normalized structure
      const normalizedData = DataTransformer.transform(rawData);
      const processed = [];

      // Set pronouns from client data
      this.setPronouns(normalizedData.clientInfo?.fields);

      // Process client info fields
      if (normalizedData.clientInfo) {
        this.processRecord(normalizedData.clientInfo, 'Client Info', null, processed);
      }

      // Process case master view records
      if (normalizedData.cases && Array.isArray(normalizedData.cases)) {
        normalizedData.cases.forEach((caseRecord, index) => {
          const caseLabel = caseRecord.caseIdentifier || `Case ${index + 1}`;
          this.processRecord(caseRecord.fields || caseRecord, 'Case Master View', caseLabel, processed);
        });
      }

      // Process events
      if (normalizedData.events && Array.isArray(normalizedData.events)) {
        normalizedData.events.forEach((eventRecord, index) => {
          const eventLabel = eventRecord.title || eventRecord.summary || `Event ${index + 1}`;
          this.processRecord(eventRecord.fields || eventRecord, 'Events', eventLabel, processed, eventRecord.recordId);
        });
      }

      // Process applications
      if (normalizedData.applications && Array.isArray(normalizedData.applications)) {
        normalizedData.applications.forEach((appRecord, index) => {
          const appLabel = appRecord.type || `Application ${index + 1}`;
          this.processRecord(appRecord.fields || appRecord, 'Applications', appLabel, processed, appRecord.recordId);
        });
      }

      return processed;
    },

    processRecord(record, sourceTable, caseLabel, results, recordIdOverride = null) {
      const fields = record.fields || record;
      const recordId = recordIdOverride || record.recordId;

      Object.entries(fields).forEach(([fieldName, value]) => {
        // Skip empty values
        if (value === null || value === undefined || value === '') return;
        if (Array.isArray(value) && value.length === 0) return;

        // Skip hidden fields
        if (Utils.isHiddenField(fieldName)) return;

        // Skip record metadata
        if (fieldName === 'recordId' || fieldName === 'caseIdentifier') return;

        const processedField = this.processField(fieldName, value, sourceTable, caseLabel, recordId);
        if (processedField) {
          results.push(processedField);
        }
      });
    },

    processField(fieldName, value, sourceTable, caseLabel, recordId) {
      const semanticConfig = CONFIG?.SEMANTIC_ROLES?.[fieldName];

      // Handle button objects specially
      if (value && typeof value === 'object' && value.type === 'button') {
        return {
          tier: 2,
          fieldName,
          value: value.url,
          rendered: value.label || fieldName,
          role: null,
          group: Utils.findGroupByPattern(fieldName) || 'Documents',
          priority: 50,
          narrativePosition: null,
          dataType: 'button',
          buttonLabel: value.label,
          buttonUrl: value.url,
          sourceTable,
          caseLabel,
          recordId
        };
      }

      // Handle attachment objects specially
      if (value && typeof value === 'object' && value.type === 'attachment') {
        return {
          tier: 2,
          fieldName,
          value: value.url,
          rendered: value.label || 'Download',
          role: null,
          group: Utils.findGroupByPattern(fieldName) || 'Documents',
          priority: 50,
          narrativePosition: null,
          dataType: 'attachment',
          buttonLabel: value.label,
          buttonUrl: value.url,
          fileType: value.fileType,
          sourceTable,
          caseLabel,
          recordId
        };
      }

      // Stringify complex values
      let displayValue = value;
      if (Array.isArray(value)) {
        displayValue = value.join(', ');
      } else if (typeof value === 'object' && value !== null) {
        // Skip error/NaN objects that slipped through
        if (value.error || value.specialValue) {
          return null;
        }
        displayValue = JSON.stringify(value);
      }
      
      // Tier 1: Semantic role defined
      if (semanticConfig) {
        const rendered = Utils.applyTemplate(semanticConfig.template, displayValue, semanticConfig.dataType);
        if (fieldName === 'Client Name') {
          console.log('[DataProcessor] Processing Client Name field:', { fieldName, value: displayValue, role: semanticConfig.role });
        }
        return {
          tier: 1,
          fieldName,
          value: displayValue,
          rendered,
          role: semanticConfig.role,
          group: semanticConfig.group,
          priority: semanticConfig.priority || 99,
          narrativePosition: semanticConfig.narrativePosition,
          dataType: semanticConfig.dataType,
          sourceTable,
          caseLabel,
          recordId
        };
      }
      
      // Tier 2: Schema-informed or pattern-matched processing
      // Use schema type first, then fall back to pattern matching
      const schemaType = SchemaProcessor.hasSchema()
        ? SchemaProcessor.getDisplayType(fieldName, displayValue)
        : null;
      const inferredType = schemaType || Utils.inferDataType(String(displayValue), fieldName);
      const group = Utils.findGroupByPattern(fieldName);

      // If we have schema info OR can match patterns, use Tier 2
      if (group || inferredType || SchemaProcessor.hasSchema()) {
        const formatted = inferredType ? Utils.formatByType(displayValue, inferredType) : displayValue;
        const displayLabel = SchemaProcessor.hasSchema()
          ? SchemaProcessor.getDisplayLabel(fieldName)
          : Utils.humanizeFieldName(fieldName);

        return {
          tier: 2,
          fieldName,
          displayLabel,
          value: displayValue,
          rendered: formatted,
          role: null,
          group: group || (SchemaProcessor.hasSchema() ? 'Other' : 'Other'),
          priority: this.calculatePriority(fieldName, inferredType),
          narrativePosition: null,
          dataType: inferredType,
          schemaType: SchemaProcessor.getFieldType(fieldName),
          sourceTable,
          caseLabel,
          recordId
        };
      }

      // Tier 3: Raw triplet (fallback when no schema and no pattern match)
      return {
        tier: 3,
        fieldName,
        displayLabel: Utils.humanizeFieldName(fieldName),
        value: displayValue,
        rendered: String(displayValue),
        role: null,
        group: 'Uncategorized',
        priority: 99,
        narrativePosition: null,
        dataType: null,
        schemaType: null,
        sourceTable,
        caseLabel,
        recordId
      };
    },

    /**
     * Calculate field priority for display ordering
     * Lower numbers = higher priority (shown first)
     */
    calculatePriority(fieldName, dataType) {
      const fieldLower = fieldName.toLowerCase();

      // Dates are important - show early
      if (dataType === 'date' || dataType === 'datetime') {
        // Upcoming/due dates first
        if (/due|upcoming|next|hearing|deadline/.test(fieldLower)) return 10;
        // Other dates
        return 30;
      }

      // Status fields are important
      if (/status|stage|decision/.test(fieldLower)) return 20;

      // Receipt numbers and IDs
      if (/receipt|number|#/.test(fieldLower)) return 40;

      // Notes and comments go later
      if (/note|comment|memo/.test(fieldLower)) return 80;

      // Default priority
      return 50;
    },

    // Compose narrative from Tier 1 fields
    composeNarrative(fields) {
      const tier1 = fields.filter(f => f.tier === 1);
      const templates = CONFIG?.NARRATIVE_TEMPLATES || {};
      const pronouns = this.pronounContext;

      const sentences = [];

      // Sort templates by order
      const orderedTemplates = Object.entries(templates)
        .sort(([,a], [,b]) => a.order - b.order);

      for (const [name, template] of orderedTemplates) {
        try {
          const sentence = template.compose(tier1, pronouns);
          if (sentence) {
            sentences.push(sentence);
          }
        } catch (e) {
          console.warn(`Error composing ${name} narrative:`, e);
        }
      }

      // Add remaining Tier 1 fields not in narrative templates
      const usedRoles = new Set(tier1.filter(f => f.narrativePosition).map(f => f.role));
      const unusedTier1 = tier1.filter(f => !usedRoles.has(f.role) && f.role !== 'client_name' && f.role !== 'a_number' && f.role !== 'date_of_birth' && f.role !== 'country_of_origin');

      if (unusedTier1.length > 0) {
        const grouped = {};
        unusedTier1.forEach(f => {
          if (!grouped[f.group]) grouped[f.group] = [];
          grouped[f.group].push(f);
        });

        Object.entries(grouped).forEach(([group, items]) => {
          const parts = items.slice(0, 3).map(i => i.rendered);
          if (parts.length) {
            sentences.push(`${group}: ${parts.join(', ')}`);
          }
        });
      }

      return sentences.join('. ') + (sentences.length ? '.' : '');
    },

    // Group fields for structured view
    groupFields(fields) {
      const groups = {};
      
      fields.forEach(field => {
        const groupName = field.group || 'Uncategorized';
        if (!groups[groupName]) {
          groups[groupName] = [];
        }
        groups[groupName].push(field);
      });
      
      // Sort fields within each group
      Object.values(groups).forEach(groupFields => {
        groupFields.sort((a, b) => {
          if (a.tier !== b.tier) return a.tier - b.tier;
          return a.priority - b.priority;
        });
      });
      
      // Sort groups by configured order
      const groupOrder = CONFIG?.GROUP_ORDER || [];
      const sortedGroups = {};
      
      groupOrder.forEach(groupName => {
        if (groups[groupName]) {
          sortedGroups[groupName] = groups[groupName];
        }
      });
      
      // Add any remaining groups not in order
      Object.keys(groups).forEach(groupName => {
        if (!sortedGroups[groupName]) {
          sortedGroups[groupName] = groups[groupName];
        }
      });
      
      return sortedGroups;
    },

    // Extract header fields
    extractHeaderFields(fields) {
      const headerRoles = CONFIG?.DISPLAY?.headerFields || ['client_name', 'a_number', 'dob'];
      return fields.filter(f => headerRoles.includes(f.role));
    }
  };

  // ==========================================================================
  // RENDERER
  // ==========================================================================

  const Renderer = {
    state: {
      viewMode: 'structured', // 'structured' or 'narrative'
      narrativeMode: 'short', // 'short' or 'long'
      showProvenance: false,
      expandedGroups: new Set(),
      selectedCase: 'all',
      selectedMatter: null, // Filter by matter type
      activeMainTab: 'overview', // Main tab: overview, matters, events, applications, notes, timeline, client
      settingsOpen: false
    },

    init(data) {
      this.data = data;
      this.processedFields = DataProcessor.processFields(data);

      // Load user preferences
      FieldPreferences.load();
      LayoutPreferences.load();

      // Initialize Field Registry for Field Canvas
      FieldRegistry.init(data, this.processedFields);

      // Make widget accessible for Field Canvas
      window.ClientGlanceWidget = this;

      // Transform data for new architecture
      this.normalizedData = DataTransformer.transform(data);

      // Detect matters
      this.matters = MatterDetector.detectMatters(this.normalizedData.cases || []);
      console.log('[Renderer] Detected matters:', this.matters.map(m => m.type));

      // Set pronouns
      NarrativeComposer.setPronouns(this.normalizedData.clientInfo?.fields);

      // Build tuples
      this.tuples = TupleProcessor.buildTuples(this.processedFields, this.matters);

      // Extract events and applications
      this.events = this.extractEvents();
      this.applications = this.extractApplications();

      // Extract ALL date fields with semantic context for timeline
      this.allDateFields = this.extractAllDateFields();
      console.log('[Renderer] Extracted', this.allDateFields.length, 'date fields for timeline');

      // Organize fields by source table for tabs
      this.organizeFieldsByTab();

      this.render();
    },

    /**
     * Extract ALL date fields from all processed data with semantic context
     * Returns timeline entries grouped by semantic category
     */
    extractAllDateFields() {
      const dateEntries = [];
      const semanticRoles = CONFIG?.SEMANTIC_ROLES || {};
      const seenDates = new Set(); // Avoid duplicates

      // Helper to check if a value looks like a date
      const isDateValue = (value) => {
        if (!value || typeof value !== 'string') return false;
        // ISO date format: YYYY-MM-DD or datetime
        if (/^\d{4}-\d{2}-\d{2}/.test(value)) return true;
        // Try parsing as date
        const parsed = new Date(value);
        return !isNaN(parsed.getTime()) && parsed.getFullYear() > 1900 && parsed.getFullYear() < 2100;
      };

      // Helper to get semantic info for a field
      const getSemanticInfo = (fieldName) => {
        const role = semanticRoles[fieldName];
        if (role) {
          return {
            template: role.template,
            group: role.group,
            dataType: role.dataType,
            role: role.role,
            priority: role.priority || 99
          };
        }
        // Fallback: try to infer group from field name patterns
        const groupPatterns = CONFIG?.FIELD_GROUP_PATTERNS || [];
        for (const { group, pattern } of groupPatterns) {
          if (pattern.test(fieldName)) {
            return { template: null, group, dataType: 'date', role: null, priority: 50 };
          }
        }
        return { template: null, group: 'Other', dataType: 'date', role: null, priority: 99 };
      };

      // FIRST: Include all Google Calendar events in the timeline
      // These are the actual calendar appointments
      if (this.events && this.events.length > 0) {
        for (const event of this.events) {
          if (!event.date) continue;

          const uniqueKey = `calendar-${event.id || event.date}-${event.title}`;
          if (seenDates.has(uniqueKey)) continue;
          seenDates.add(uniqueKey);

          // Build a rich title for the calendar event
          let title = event.title || 'Calendar Event';
          if (event.location) {
            title += ` at ${event.location}`;
          }
          if (event.eventType && event.eventType !== 'event') {
            title = `${event.eventType}: ${title}`;
          }

          dateEntries.push({
            date: event.date,
            endDate: event.endDate,
            title: title,
            fieldName: 'Calendar Event',
            group: 'Calendar',
            priority: 1, // Calendar events are high priority
            caseLabel: event.caseLabel || null,
            sourceTable: 'Google Calendar',
            matter: event.matter,
            urgency: event.urgency || MatterDetector.getDateUrgency(event.date),
            isDateTimeField: !event.isAllDay,
            isCalendarEvent: true,
            location: event.location,
            description: event.description,
            attendees: event.attendees,
            organizer: event.organizer,
            htmlLink: event.htmlLink,
            eventId: event.id
          });
        }
      }

      // SECOND: Scan all processed fields for date values
      // This captures all other dates from the data (filing dates, deadlines, etc.)
      for (const field of this.processedFields) {
        // Check if this field has date data type in semantic roles
        const semantic = getSemanticInfo(field.fieldName);
        const isDateField = semantic.dataType === 'date' || semantic.dataType === 'datetime';

        // Also check if the value looks like a date
        const hasDateValue = isDateValue(field.value);

        if ((isDateField || hasDateValue) && field.value) {
          // Create a unique key to avoid duplicates
          const uniqueKey = `${field.fieldName}-${field.value}-${field.caseLabel || 'default'}`;
          if (seenDates.has(uniqueKey)) continue;
          seenDates.add(uniqueKey);

          // Always show the field name clearly in the title
          const title = Utils.humanizeFieldName(field.fieldName);

          dateEntries.push({
            date: field.value,
            title: title,
            fieldName: field.fieldName,
            group: semantic.group,
            priority: semantic.priority,
            caseLabel: field.caseLabel,
            sourceTable: field.sourceTable,
            matter: this.inferMatterFromCase(field.caseLabel),
            urgency: MatterDetector.getDateUrgency(field.value),
            isDateTimeField: semantic.dataType === 'datetime',
            isCalendarEvent: false
          });
        }
      }

      // Sort by date (future first, then past in reverse chronological)
      dateEntries.sort((a, b) => {
        if (!a.date && !b.date) return 0;
        if (!a.date) return 1;
        if (!b.date) return -1;
        return new Date(a.date) - new Date(b.date);
      });

      console.log('[Renderer] Timeline entries:', dateEntries.length, '(including',
        dateEntries.filter(e => e.isCalendarEvent).length, 'calendar events)');

      return dateEntries;
    },

    /**
     * Extract events from multiple sources:
     * 1. normalizedData.events (from webhook Events table)
     * 2. Google Calendar data
     * 3. Legacy extraction from processed fields
     */
    extractEvents() {
      const events = [];
      const seenIds = new Set();

      // Helper to add event if not duplicate
      const addEvent = (event) => {
        const key = event.id || `${event.date}-${event.title}`;
        if (seenIds.has(key)) return;
        seenIds.add(key);
        events.push(event);
      };

      // Primary source: Events from normalized webhook data (Events table records)
      if (this.normalizedData?.events?.length > 0) {
        console.log('[Renderer] Loading', this.normalizedData.events.length, 'events from webhook Events table');
        for (const event of this.normalizedData.events) {
          addEvent({
            id: event.recordId,
            date: event.startDate,
            endDate: event.endDate,
            title: event.title,
            location: event.location,
            description: event.fields?.Description || '',
            details: event.fields?.Details || '',
            recordId: event.recordId,
            fields: event.fields,
            matter: this.inferMatterFromCase(event.title),
            urgency: event.startDate ? MatterDetector.getDateUrgency(event.startDate) : 'unknown',
            source: 'webhook',
            group: 'Calendar',
            isCalendarEvent: true
          });
        }
      }

      // Secondary source: Google Calendar data (window.GOOGLE_CALENDAR_DATA)
      if (window.GOOGLE_CALENDAR_DATA) {
        const calendarEvents = GoogleCalendarParser.parseEvents(window.GOOGLE_CALENDAR_DATA);
        console.log('[Renderer] Loaded', calendarEvents.length, 'events from Google Calendar');
        for (const event of calendarEvents) {
          addEvent(event);
        }
      }

      // Tertiary: Extract calendar-like events from main data
      const dataEvents = DataFetcher.extractCalendarEventsFromData(this.data);
      for (const event of dataEvents) {
        addEvent(event);
      }

      // If still no events, fall back to legacy extraction
      if (events.length === 0) {
        console.log('[Renderer] No events found, using legacy extraction');
        const legacyEvents = this.extractLegacyEvents();
        events.push(...legacyEvents);
      }

      // Sort by date (events without dates go last)
      events.sort((a, b) => {
        if (!a.date && !b.date) return 0;
        if (!a.date) return 1;
        if (!b.date) return -1;
        return new Date(a.date) - new Date(b.date);
      });

      console.log('[Renderer] Total events extracted:', events.length);
      return events;
    },

    /**
     * Legacy event extraction from Events table (fallback)
     */
    extractLegacyEvents() {
      const events = [];

      // Get fields from Events source table
      const eventFields = this.processedFields.filter(f =>
        f.sourceTable && f.sourceTable.toLowerCase().includes('event')
      );

      // Group by recordId to identify unique event records
      const eventsByRecord = {};
      for (const field of eventFields) {
        const recordId = field.recordId || field.caseLabel || 'default';
        if (!eventsByRecord[recordId]) {
          eventsByRecord[recordId] = {
            fields: {},
            caseLabel: field.caseLabel,
            sourceTable: field.sourceTable
          };
        }
        eventsByRecord[recordId].fields[field.fieldName] = field.value;
      }

      // Create event objects from grouped records
      for (const [recordId, record] of Object.entries(eventsByRecord)) {
        const fields = record.fields;
        // Look for date field (Events table uses Created At, Created date, or Hearing Date/Time)
        const dateValue = fields['Hearing Date/Time'] || fields['Created At'] ||
                          fields['Created date'] || fields['Event Date'] || fields['Date'];
        // Look for event title (Activity field is primary in Events table)
        const eventName = fields['Activity'] || fields['Event Name'] || fields['Hearing Type'] ||
                          fields['Event Hearing Type'] || fields['Description'] || 'Event';
        // Details provide additional context
        const details = fields['Details'] || fields['Case Notes'] || '';

        events.push({
          id: recordId,
          date: dateValue,
          title: eventName,
          description: details,
          details: details,
          recordId,
          fields: fields,
          caseLabel: record.caseLabel,
          matter: this.inferMatterFromCase(record.caseLabel),
          urgency: dateValue ? MatterDetector.getDateUrgency(dateValue) : 'unknown',
          source: 'legacy',
          group: 'Calendar'
        });
      }

      return events;
    },

    /**
     * Extract application records from:
     * 1. normalizedData.applications (from webhook Applications table)
     * 2. Legacy extraction from processed fields
     */
    extractApplications() {
      const applications = [];
      const seenIds = new Set();

      // Primary source: Applications from normalized webhook data
      if (this.normalizedData?.applications?.length > 0) {
        console.log('[Renderer] Loading', this.normalizedData.applications.length, 'applications from webhook');
        for (const app of this.normalizedData.applications) {
          if (seenIds.has(app.recordId)) continue;
          seenIds.add(app.recordId);
          applications.push({
            recordId: app.recordId,
            name: app.type,
            application: app.type,
            status: app.fields?.Status,
            receiptNumber: app.fields?.['Receipt Number'],
            receiptDate: app.fields?.['Filed Date'],
            matter: this.inferMatterFromCase(app.type),
            caseId: app.caseId,
            fields: app.fields,
            source: 'webhook'
          });
        }
      }

      // Secondary: Legacy extraction from processed fields
      const appFields = this.tabData?.applications?.fields || [];
      const byRecord = {};
      for (const field of appFields) {
        const recordId = field.recordId || 'default';
        if (seenIds.has(recordId)) continue;
        if (!byRecord[recordId]) byRecord[recordId] = {};
        byRecord[recordId][field.fieldName] = field.value;
        byRecord[recordId].caseLabel = field.caseLabel;
      }

      for (const [recordId, fields] of Object.entries(byRecord)) {
        if (seenIds.has(recordId)) continue;
        seenIds.add(recordId);
        applications.push({
          recordId,
          name: fields['Name'] || fields['Application'],
          application: fields['Application'],
          status: fields['Status'],
          receiptNumber: fields['Receipt Number'],
          receiptDate: fields['Receipt Date'],
          matter: this.inferMatterFromCase(fields.caseLabel),
          fields,
          source: 'legacy'
        });
      }

      console.log('[Renderer] Total applications:', applications.length);
      return applications;
    },

    /**
     * Infer matter type from case label
     */
    inferMatterFromCase(caseLabel) {
      if (!caseLabel) return null;

      const matterTypes = CONFIG?.MATTER_TYPES || {};
      for (const [typeId, config] of Object.entries(matterTypes)) {
        const patterns = config.detectPatterns || [];
        if (patterns.some(p => p.test(caseLabel))) {
          return typeId;
        }
      }
      return null;
    },

    /**
     * Organize processed fields by their source table for tab display
     */
    organizeFieldsByTab() {
      const tabs = CONFIG?.MAIN_TABS || {};
      this.tabData = {};

      for (const [tabId, tabConfig] of Object.entries(tabs)) {
        const sourceTables = tabConfig.sourceTables || [];
        this.tabData[tabId] = {
          config: tabConfig,
          fields: this.processedFields.filter(f => {
            // Match by source table - require non-empty sourceTable for matching
            if (f.sourceTable && sourceTables.some(t =>
              f.sourceTable === t ||
              f.sourceTable.toLowerCase().includes(t.toLowerCase()) ||
              t.toLowerCase().includes(f.sourceTable.toLowerCase())
            )) return true;
            // For client tab, include fields without sourceTable (from client info)
            if (tabId === 'client' && (!f.sourceTable || f.sourceTable === 'Client Info')) return true;
            // For overview, include critical fields from any source
            if (tabId === 'overview') return FieldClassifier.isPriority(f.fieldName);
            return false;
          }),
          allFieldNames: new Set()
        };

        // Collect all unique field names for settings
        this.tabData[tabId].fields.forEach(f => {
          this.tabData[tabId].allFieldNames.add(f.fieldName);
        });
      }
    },

    render() {
      const container = document.getElementById('app');

      const headerFields = DataProcessor.extractHeaderFields(this.processedFields);
      const clientNameField = headerFields.find(f => f.role === 'client_name');
      const clientName = clientNameField?.value || 'Unknown Client';
      console.log('[Renderer] Header fields:', headerFields.map(f => ({ fieldName: f.fieldName, role: f.role, value: f.value })));
      console.log('[Renderer] Client name field:', clientNameField);
      console.log('[Renderer] Display client name:', clientName);

      // Get unique cases for the case filter (within Cases tab) - only show cases with actual data
      const cases = [...new Set(this.processedFields.filter(f => f.caseLabel && f.value !== undefined && f.value !== null && f.value !== '').map(f => f.caseLabel))];

      container.innerHTML = `
        <div class="widget-header">
          <span class="widget-title">Client At-a-Glance</span>
          <div class="view-toggle">
            <button class="${this.state.viewMode === 'structured' ? 'active' : ''}" data-view="structured">
              Structured
            </button>
            <button class="${this.state.viewMode === 'narrative' ? 'active' : ''}" data-view="narrative">
              Narrative
            </button>
          </div>
        </div>

        ${this.renderClientHeader(headerFields, clientName)}

        ${this.renderMainTabs()}

        ${this.renderTabContent(cases)}

        <div class="settings-row">
          <label class="settings-toggle">
            <input type="checkbox" ${this.state.showProvenance ? 'checked' : ''} data-setting="provenance">
            Show sources
          </label>
        </div>
      `;

      this.attachEventListeners();
    },

    renderClientHeader(headerFields, clientName) {
      const aNum = headerFields.find(f => f.role === 'a_number');
      const dob = headerFields.find(f => f.role === 'date_of_birth');
      const country = headerFields.find(f => f.role === 'country_of_origin');
      const age = headerFields.find(f => f.role === 'age');

      return `
        <div class="client-header">
          <div class="client-name">${Utils.escapeHtml(clientName)}</div>
          <div class="client-meta">
            ${aNum ? `<span class="client-meta-item"><span class="client-meta-label">A#</span> ${Utils.escapeHtml(aNum.value)}</span>` : ''}
            ${dob ? `<span class="client-meta-item"><span class="client-meta-label">DOB</span> ${Utils.escapeHtml(dob.rendered)}${age ? ` (${age.value})` : ''}</span>` : ''}
            ${country ? `<span class="client-meta-item"><span class="client-meta-label">From</span> ${Utils.escapeHtml(country.value)}</span>` : ''}
          </div>
          ${this.renderMatterPills()}
        </div>
      `;
    },

    /**
     * Render matter pills for filtering
     */
    renderMatterPills() {
      if (!this.matters || this.matters.length === 0) return '';

      const uniqueTypes = [...new Set(this.matters.map(m => m.type))];

      return `
        <div class="matter-pills">
          ${uniqueTypes.map(typeId => {
            const config = CONFIG?.MATTER_TYPES?.[typeId] || {};
            const isActive = this.state.selectedMatter === typeId;
            const matter = this.matters.find(m => m.type === typeId);
            const status = matter?.status;

            return `
              <button class="matter-pill ${typeId} ${isActive ? 'active' : ''}"
                      data-matter="${typeId}"
                      title="${config.label || typeId}${status ? ': ' + status : ''}">
                <span class="matter-dot"></span>
                ${Utils.escapeHtml(config.shortLabel || config.label || typeId)}
                ${status ? `<span style="opacity:0.7;font-weight:400">¬∑ ${Utils.escapeHtml(status)}</span>` : ''}
              </button>
            `;
          }).join('')}
          ${this.state.selectedMatter ? `
            <button class="matter-pill" data-matter="clear" style="background:#f3f4f6;color:#6b7280;">
              ‚úï Clear
            </button>
          ` : ''}
        </div>
      `;
    },

    /**
     * Render the main navigation tabs
     */
    renderMainTabs() {
      const tabs = CONFIG?.MAIN_TABS || {};

      // Define tab order for display
      const tabOrder = ['overview', 'client', 'matters', 'events', 'applications', 'notes', 'timeline'];

      return `
        <div class="main-tabs">
          ${tabOrder.filter(tabId => tabs[tabId]).map(tabId => {
            const tabConfig = tabs[tabId];
            // Different count logic per tab type
            let count = '';
            if (tabId === 'matters') {
              // Count unique matter types (e.g., SIJ, Asylum, Family), not total case records
              const uniqueMatterTypes = [...new Set((this.matters || []).map(m => m.type))];
              count = uniqueMatterTypes.length || 0;
            } else if (tabId === 'events') {
              count = this.events?.filter(e => e.urgency !== 'past').length || 0;
            } else if (tabId === 'applications') {
              count = this.applications?.length || 0;
            } else if (tabId === 'notes') {
              // Count fields that have "note" in the field name (case-insensitive)
              count = this.processedFields?.filter(f =>
                f.fieldName && f.fieldName.toLowerCase().includes('note') && f.value
              ).length || 0;
            } else if (tabId === 'client') {
              // Count client info fields with values
              count = this.tabData[tabId]?.fields?.filter(f => f.value).length || 0;
            } else if (tabId !== 'overview' && tabId !== 'timeline') {
              count = this.tabData[tabId]?.fields?.filter(f => f.value).length || 0;
            }

            return `
              <button class="main-tab ${this.state.activeMainTab === tabId ? 'active' : ''}"
                      data-main-tab="${tabId}"
                      title="${tabConfig.description || ''}">
                ${tabConfig.icon || ''} ${tabConfig.label}
                ${count !== '' ? `<span class="tab-count">${count}</span>` : ''}
              </button>
            `;
          }).join('')}
        </div>
      `;
    },

    /**
     * Render content for the active tab
     */
    renderTabContent(cases) {
      const activeTab = this.state.activeMainTab;
      const tabConfig = CONFIG?.MAIN_TABS?.[activeTab];
      const tabData = this.tabData[activeTab];
      const viewType = tabConfig?.viewType || 'structured';

      // Filter by selected matter if set
      let displayFields = tabData?.fields || [];
      if (this.state.selectedMatter) {
        displayFields = displayFields.filter(f => {
          const fieldMatter = this.inferMatterFromCase(f.caseLabel);
          return !fieldMatter || fieldMatter === this.state.selectedMatter;
        });
      }

      // Route to appropriate view renderer based on viewType
      switch (viewType) {
        case 'overview':
          return this.renderOverviewView();

        case 'tupelized':
          return this.renderMattersView(cases);

        case 'timeline':
          return this.renderTimelineView(activeTab);

        case 'events':
          return this.renderEventsView();

        case 'notes':
          return this.renderNotesView();

        case 'cards':
          return this.renderApplicationsView();

        case 'structured':
        default:
          return this.renderStructuredTabContent(cases, displayFields, activeTab, tabData);
      }
    },

    /**
     * Render Overview tab - summary with matter cards and upcoming events
     */
    renderOverviewView() {
      const upcomingEvents = this.events.filter(e => e.urgency !== 'past').slice(0, 5);

      // Short/long narrative toggle
      const narrative = this.state.narrativeMode === 'long'
        ? NarrativeComposer.composeLong(
            this.normalizedData.clientInfo,
            this.matters,
            this.tuples,
            upcomingEvents,
            this.applications
          )
        : NarrativeComposer.composeShort(
            this.normalizedData.clientInfo,
            this.matters,
            upcomingEvents
          );

      return `
        <div class="narrative-toggle">
          <button class="${this.state.narrativeMode === 'short' ? 'active' : ''}" data-narrative="short">Summary</button>
          <button class="${this.state.narrativeMode === 'long' ? 'active' : ''}" data-narrative="long">Full Detail</button>
        </div>

        ${this.state.narrativeMode === 'short' ? `
          <div class="narrative-view">
            <div class="narrative-text">${narrative || '<em>No data available.</em>'}</div>
          </div>
        ` : `
          <div class="narrative-view">
            ${Array.isArray(narrative) ? narrative.map(section => `
              <div style="margin-bottom: 16px;">
                <div style="font-weight: 600; font-size: 12px; color: var(--text-muted); margin-bottom: 6px; text-transform: uppercase;">
                  ${Utils.escapeHtml(section.title)}
                </div>
                <div class="narrative-text" style="white-space: pre-wrap;">${Utils.escapeHtml(section.content)}</div>
              </div>
            `).join('') : `<div class="narrative-text">${Utils.escapeHtml(narrative)}</div>`}
          </div>
        `}

        <div class="overview-section">
          <div class="overview-section-title">Active Matters</div>
          <div class="matter-cards">
            ${this.matters.length > 0 ? this.matters.map(matter => this.renderMatterCard(matter)).join('') : '<div class="no-data">No active matters detected.</div>'}
          </div>
        </div>

        <div class="overview-section">
          <div class="overview-section-title">Upcoming</div>
          <div class="upcoming-events">
            ${upcomingEvents.length > 0 ? upcomingEvents.map(event => `
              <div class="upcoming-event">
                <div class="event-urgency ${event.urgency || 'scheduled'}"></div>
                <div class="event-content">
                  <div class="event-date">${Utils.formatDate(event.date, true)}</div>
                  <div class="event-title">${Utils.escapeHtml(event.title)}</div>
                  ${event.matter ? `
                    <span class="event-matter-tag ${event.matter}" style="background: ${CONFIG?.MATTER_TYPES?.[event.matter]?.color || '#6b7280'}20; color: ${CONFIG?.MATTER_TYPES?.[event.matter]?.color || '#6b7280'}">
                      ${CONFIG?.MATTER_TYPES?.[event.matter]?.shortLabel || event.matter}
                    </span>
                  ` : ''}
                </div>
              </div>
            `).join('') : '<div class="no-data" style="padding: 16px;">No upcoming events.</div>'}
          </div>
        </div>
      `;
    },

    /**
     * Render a single matter card
     */
    renderMatterCard(matter) {
      const config = matter.typeConfig || {};
      const statusColor = MatterDetector.getStatusColor(matter.status);

      // Get key details from the matter's related tuple
      const relatedTuple = this.tuples.find(t => t.matterType === matter.type);
      const keyFields = relatedTuple?.fields.slice(0, 3) || [];

      return `
        <div class="matter-card" data-matter-card="${matter.type}">
          <div class="matter-card-header">
            <span class="matter-card-type" style="color: ${config.color || '#374151'}">
              ${Utils.escapeHtml(config.label || matter.type)}
            </span>
            ${matter.status ? `
              <span class="matter-card-status status-${statusColor}">
                ${Utils.escapeHtml(matter.status)}
              </span>
            ` : ''}
          </div>
          <div class="matter-card-details">
            ${keyFields.map(f => `
              <div class="matter-card-detail">
                ${Utils.escapeHtml(f.displayLabel || Utils.humanizeFieldName(f.fieldName))}:
                <strong>${Utils.escapeHtml(f.format === 'date' ? Utils.formatDate(f.value) : f.value)}</strong>
              </div>
            `).join('')}
          </div>
        </div>
      `;
    },

    /**
     * Render Matters tab - tupelized field display
     */
    renderMattersView(cases) {
      const activeTab = this.state.activeMainTab;
      const tabData = this.tabData[activeTab];

      // Filter tuples by selected matter
      let displayTuples = this.tuples;
      if (this.state.selectedMatter) {
        displayTuples = this.tuples.filter(t =>
          t.matterType === this.state.selectedMatter ||
          t.matterAgnostic ||
          !t.matterType
        );
      }

      // Show case filter if multiple cases
      const showCaseFilter = cases.length > 1;

      return `
        ${showCaseFilter ? this.renderCaseTabs(cases) : ''}

        <div class="structured-view">
          ${displayTuples.length > 0 ? displayTuples.map(tuple => this.renderTupleCard(tuple)).join('') : `
            <div class="no-data">No data available for ${this.state.selectedMatter ? 'this matter type' : 'matters'}.</div>
          `}
        </div>

        ${tabData && tabData.fields.length > 0 ? this.renderSettingsPanel(activeTab, tabData) : ''}
      `;
    },

    /**
     * Render a semantic tuple card
     */
    renderTupleCard(tuple) {
      const status = TupleProcessor.getTupleStatus(tuple);
      const statusColor = status ? MatterDetector.getStatusColor(status) : null;
      const matterConfig = tuple.matterType ? CONFIG?.MATTER_TYPES?.[tuple.matterType] : null;

      return `
        <div class="tuple-card">
          <div class="tuple-card-header">
            <span class="tuple-card-title">
              ${matterConfig ? `<span style="color: ${matterConfig.color}">${Utils.escapeHtml(matterConfig.shortLabel)}</span> ` : ''}
              ${Utils.escapeHtml(tuple.label)}
            </span>
            ${status ? `
              <span class="tuple-card-status status-${statusColor}">
                ${Utils.escapeHtml(status)}
              </span>
            ` : ''}
          </div>
          <div class="tuple-card-content">
            ${tuple.fields.filter(f => f.displayAs !== 'status').map(field => {
              const label = field.displayLabel || Utils.humanizeFieldName(field.fieldName);
              let value = field.rendered || field.value;

              // Format by type
              if (field.format === 'date') value = Utils.formatDate(value);
              if (field.format === 'datetime') value = Utils.formatDate(value, true);
              if (field.format === 'phone') value = Utils.formatPhone(value);

              // Add urgency indicator
              const urgencyClass = field.urgency ? `event-urgency ${field.urgency}` : '';

              return `
                <div class="tuple-field-row">
                  <span class="tuple-field-label">
                    ${field.urgency ? `<span class="${urgencyClass}" style="display:inline-block;width:6px;height:6px;border-radius:50%;margin-right:6px;"></span>` : ''}
                    ${Utils.escapeHtml(label)}
                  </span>
                  <span class="tuple-field-value">${this.renderFieldValue(field)}</span>
                </div>
              `;
            }).join('')}
          </div>
        </div>
      `;
    },

    /**
     * Render Timeline view - shows ALL date fields with semantic context
     */
    renderTimelineView(activeTab) {
      // Use all date fields extracted with semantic context
      let dateEntries = [...(this.allDateFields || [])];

      // Filter by matter if selected
      if (this.state.selectedMatter) {
        dateEntries = dateEntries.filter(e => !e.matter || e.matter === this.state.selectedMatter);
      }

      // Separate future and past
      const futureEntries = dateEntries.filter(e => e.urgency !== 'past');
      const pastEntries = dateEntries.filter(e => e.urgency === 'past').reverse();

      // Group future entries by semantic group for better organization
      // Calendar events are shown first, then by semantic category
      const groupOrder = CONFIG?.GROUP_ORDER || ['Calendar', 'Court', 'SIJ', 'USCIS', 'EAD', 'Asylum', 'U-Visa', 'Appeals', 'Bond', 'FOIA', 'Identity', 'Other'];
      const groupColors = {
        'Calendar': '#4285f4',   // Google blue - for calendar events
        'Court': '#dc2626',      // red
        'SIJ': '#15803d',        // green
        'USCIS': '#0369a1',      // blue
        'EAD': '#7c3aed',        // purple
        'Asylum': '#0369a1',     // blue
        'U-Visa': '#7c3aed',     // purple
        'Appeals': '#b45309',    // amber
        'Bond': '#be123c',       // rose
        'FOIA': '#6b7280',       // gray
        'Identity': '#525252',   // neutral
        'Other': '#6b7280'       // gray
      };

      // Group future entries
      const futureByGroup = {};
      for (const entry of futureEntries) {
        const group = entry.group || 'Other';
        if (!futureByGroup[group]) futureByGroup[group] = [];
        futureByGroup[group].push(entry);
      }

      // Sort each group by date
      for (const group of Object.keys(futureByGroup)) {
        futureByGroup[group].sort((a, b) => new Date(a.date) - new Date(b.date));
      }

      // Helper to render a single timeline entry
      const renderEntry = (entry, isFuture = false) => {
        const groupColor = groupColors[entry.group] || '#6b7280';
        const matterConfig = entry.matter ? CONFIG?.MATTER_TYPES?.[entry.matter] : null;
        const isCalendarEvent = entry.isCalendarEvent || entry.group === 'Calendar';

        return `
          <div class="timeline-item ${isFuture ? 'future' : ''} ${isCalendarEvent ? 'calendar-event' : ''}" data-urgency="${entry.urgency || 'unknown'}">
            <div class="timeline-date">
              ${Utils.formatDate(entry.date, entry.isDateTimeField)}
              ${entry.endDate ? `<span class="timeline-date-end"> ‚Äì ${Utils.formatDate(entry.endDate, entry.isDateTimeField)}</span>` : ''}
            </div>
            <div class="timeline-content">
              <div class="timeline-title">
                ${isCalendarEvent ? '<span class="calendar-icon">üìÖ</span> ' : ''}
                ${Utils.escapeHtml(entry.title)}
                ${entry.htmlLink ? `<a href="${entry.htmlLink}" target="_blank" class="calendar-link" title="Open in Google Calendar">‚Üó</a>` : ''}
              </div>
              ${isCalendarEvent && entry.location ? `
                <div class="timeline-location">
                  <span class="location-icon">üìç</span> ${Utils.escapeHtml(entry.location)}
                </div>
              ` : ''}
              ${isCalendarEvent && entry.description ? `
                <div class="timeline-description">${Utils.escapeHtml(entry.description.substring(0, 150))}${entry.description.length > 150 ? '...' : ''}</div>
              ` : ''}
              ${isCalendarEvent && entry.attendees && entry.attendees.length > 0 ? `
                <div class="timeline-attendees">
                  <span class="attendees-icon">üë•</span> ${entry.attendees.slice(0, 3).map(a => a.name || a.email).join(', ')}${entry.attendees.length > 3 ? ` +${entry.attendees.length - 3} more` : ''}
                </div>
              ` : ''}
              <div class="timeline-meta">
                <span class="timeline-group-tag" style="background: ${groupColor}15; color: ${groupColor}; border: 1px solid ${groupColor}30;">
                  ${isCalendarEvent ? 'üìÖ ' : ''}${entry.group || 'Other'}
                </span>
                ${entry.matter && matterConfig ? `
                  <span class="event-matter-tag ${entry.matter}" style="background: ${matterConfig.color || '#6b7280'}20; color: ${matterConfig.color || '#6b7280'}">
                    ${matterConfig.shortLabel || entry.matter}
                  </span>
                ` : ''}
              </div>
            </div>
          </div>
        `;
      };

      // Render future entries grouped by semantic category
      const renderFutureSection = () => {
        if (futureEntries.length === 0) {
          return '<div class="no-data">No upcoming dates.</div>';
        }

        // Render groups in order
        const sections = [];
        for (const group of groupOrder) {
          const entries = futureByGroup[group];
          if (entries && entries.length > 0) {
            sections.push(`
              <div class="timeline-group">
                <div class="timeline-group-header" style="color: ${groupColors[group] || '#6b7280'}">
                  ${group}
                </div>
                ${entries.map(e => renderEntry(e, true)).join('')}
              </div>
            `);
          }
        }

        // Add any groups not in the standard order
        for (const group of Object.keys(futureByGroup)) {
          if (!groupOrder.includes(group)) {
            const entries = futureByGroup[group];
            sections.push(`
              <div class="timeline-group">
                <div class="timeline-group-header" style="color: ${groupColors[group] || '#6b7280'}">
                  ${group}
                </div>
                ${entries.map(e => renderEntry(e, true)).join('')}
              </div>
            `);
          }
        }

        return sections.join('');
      };

      return `
        <div class="overview-section">
          <div class="overview-section-title">Upcoming Dates</div>
          <div class="timeline-view timeline-grouped">
            ${renderFutureSection()}
          </div>
        </div>

        ${pastEntries.length > 0 ? `
          <div class="overview-section" style="margin-top: 24px;">
            <div class="overview-section-title">History (${Math.min(pastEntries.length, 20)} most recent)</div>
            <div class="timeline-view">
              ${pastEntries.slice(0, 20).map(entry => renderEntry(entry, false)).join('')}
            </div>
          </div>
        ` : ''}
      `;
    },

    /**
     * Render Events view - shows Google Calendar events grouped by urgency
     * This is the primary Events tab display for calendar appointments
     */
    renderEventsView() {
      // Get calendar events (these are already extracted from Google Calendar data)
      let events = [...(this.events || [])];

      // Filter by matter if selected
      if (this.state.selectedMatter) {
        events = events.filter(e => !e.matter || e.matter === this.state.selectedMatter);
      }

      // Group events by urgency
      const urgentEvents = events.filter(e => e.urgency === 'urgent');
      const upcomingEvents = events.filter(e => e.urgency === 'upcoming');
      const scheduledEvents = events.filter(e => e.urgency === 'scheduled');
      const pastEvents = events.filter(e => e.urgency === 'past').slice(0, 10);

      // Urgency labels and colors
      const urgencyConfig = {
        urgent: { label: 'Urgent (Within 7 Days)', color: '#dc2626', icon: 'üî¥' },
        upcoming: { label: 'Upcoming (Within 30 Days)', color: '#f59e0b', icon: 'üü°' },
        scheduled: { label: 'Scheduled (Within 90 Days)', color: '#10b981', icon: 'üü¢' },
        past: { label: 'Past Events', color: '#6b7280', icon: '‚ö™' }
      };

      // Helper to render a single event card
      const renderEventCard = (event) => {
        const matterConfig = event.matter ? CONFIG?.MATTER_TYPES?.[event.matter] : null;

        return `
          <div class="event-card ${event.urgency || ''}" data-event-id="${event.id || ''}">
            <div class="event-card-header">
              <div class="event-card-date">
                <span class="event-date-primary">${Utils.formatDate(event.date, !event.isAllDay)}</span>
                ${event.endDate ? `<span class="event-date-end"> ‚Äì ${Utils.formatDate(event.endDate, !event.isAllDay)}</span>` : ''}
              </div>
              ${event.htmlLink ? `<a href="${event.htmlLink}" target="_blank" class="event-calendar-link" title="Open in Google Calendar">üìÖ View</a>` : ''}
            </div>

            <div class="event-card-title">
              ${Utils.escapeHtml(event.title)}
            </div>

            ${event.location ? `
              <div class="event-card-location">
                <span class="event-location-icon">üìç</span>
                ${Utils.escapeHtml(event.location)}
              </div>
            ` : ''}

            ${event.description ? `
              <div class="event-card-description">
                ${Utils.escapeHtml(event.description.substring(0, 200))}${event.description.length > 200 ? '...' : ''}
              </div>
            ` : ''}

            ${event.attendees && event.attendees.length > 0 ? `
              <div class="event-card-attendees">
                <span class="event-attendees-icon">üë•</span>
                ${event.attendees.slice(0, 5).map(a => Utils.escapeHtml(a.name || a.email)).join(', ')}
                ${event.attendees.length > 5 ? ` +${event.attendees.length - 5} more` : ''}
              </div>
            ` : ''}

            ${event.organizer ? `
              <div class="event-card-organizer">
                <span class="event-organizer-label">Organizer:</span> ${Utils.escapeHtml(event.organizer)}
              </div>
            ` : ''}

            <div class="event-card-footer">
              ${event.matter && matterConfig ? `
                <span class="event-matter-tag ${event.matter}" style="background: ${matterConfig.color || '#6b7280'}20; color: ${matterConfig.color || '#6b7280'}">
                  ${matterConfig.shortLabel || event.matter}
                </span>
              ` : ''}
              ${event.eventType && event.eventType !== 'event' ? `
                <span class="event-type-tag">${Utils.escapeHtml(event.eventType)}</span>
              ` : ''}
              ${event.source === 'google_calendar' ? `
                <span class="event-source-tag google">üìÖ Google Calendar</span>
              ` : ''}
            </div>
          </div>
        `;
      };

      // Helper to render a section of events
      const renderEventSection = (eventList, config) => {
        if (eventList.length === 0) return '';

        return `
          <div class="events-section ${config.label.toLowerCase().replace(/[^a-z]/g, '-')}">
            <div class="events-section-header" style="color: ${config.color}">
              <span class="events-section-icon">${config.icon}</span>
              <span class="events-section-title">${config.label}</span>
              <span class="events-section-count">${eventList.length}</span>
            </div>
            <div class="events-list">
              ${eventList.map(e => renderEventCard(e)).join('')}
            </div>
          </div>
        `;
      };

      // Check if we have any events at all
      const hasEvents = events.length > 0;

      return `
        <div class="events-view">
          ${!hasEvents ? `
            <div class="no-events-message">
              <div class="no-events-icon">üìÖ</div>
              <div class="no-events-title">No Calendar Events</div>
              <div class="no-events-text">
                Google Calendar events will appear here when available.
                <br><br>
                <small>To load calendar events, provide data via <code>window.GOOGLE_CALENDAR_DATA</code></small>
              </div>
            </div>
          ` : `
            ${renderEventSection(urgentEvents, urgencyConfig.urgent)}
            ${renderEventSection(upcomingEvents, urgencyConfig.upcoming)}
            ${renderEventSection(scheduledEvents, urgencyConfig.scheduled)}
            ${pastEvents.length > 0 ? `
              <div class="events-section-divider"></div>
              ${renderEventSection(pastEvents, urgencyConfig.past)}
            ` : ''}
          `}
        </div>
      `;
    },

    /**
     * Render Notes view - unified feed with matter labels
     */
    renderNotesView() {
      const notes = [];

      // Extract notes from all sources - any field with "note" in the name (case-insensitive)
      for (const field of this.processedFields) {
        if (field.fieldName && field.fieldName.toLowerCase().includes('note') && field.value) {
          notes.push({
            content: field.value,
            fieldName: field.fieldName,
            caseLabel: field.caseLabel,
            matter: this.inferMatterFromCase(field.caseLabel),
            sourceTable: field.sourceTable
          });
        }
      }

      // Filter by matter if selected
      let displayNotes = notes;
      if (this.state.selectedMatter) {
        displayNotes = notes.filter(n => !n.matter || n.matter === this.state.selectedMatter);
      }

      return `
        <div class="notes-feed">
          ${displayNotes.length > 0 ? displayNotes.map(note => {
            const matterConfig = note.matter ? CONFIG?.MATTER_TYPES?.[note.matter] : null;
            const isLong = String(note.content).length > 300;

            return `
              <div class="note-card">
                <div class="note-card-header">
                  ${note.matter ? `
                    <span class="note-matter-tag" style="background: ${matterConfig?.color || '#6b7280'}20; color: ${matterConfig?.color || '#6b7280'}">
                      ${matterConfig?.shortLabel || note.matter}
                    </span>
                  ` : `
                    <span class="note-matter-tag" style="background: #f3f4f6; color: #6b7280;">
                      ${Utils.escapeHtml(note.caseLabel || note.fieldName)}
                    </span>
                  `}
                  <span class="note-date">${Utils.escapeHtml(note.fieldName)}</span>
                </div>
                <div class="note-content ${isLong ? 'truncated' : ''}" data-full="${Utils.escapeHtml(note.content)}">
                  ${Utils.escapeHtml(isLong ? note.content.slice(0, 300) + '...' : note.content)}
                </div>
                ${isLong ? `
                  <div class="note-expand-btn" data-action="expand-note">Read more</div>
                ` : ''}
              </div>
            `;
          }).join('') : '<div class="no-data">No notes found.</div>'}
        </div>
      `;
    },

    /**
     * Render Applications view - cards
     */
    renderApplicationsView() {
      let apps = this.applications;

      // Filter by matter if selected
      if (this.state.selectedMatter) {
        apps = apps.filter(a => !a.matter || a.matter === this.state.selectedMatter);
      }

      return `
        <div class="application-cards">
          ${apps.length > 0 ? apps.map(app => {
            const matterConfig = app.matter ? CONFIG?.MATTER_TYPES?.[app.matter] : null;
            const statusColor = MatterDetector.getStatusColor(app.status);

            return `
              <div class="application-card">
                <div class="application-card-header">
                  <div>
                    <div class="application-type">${Utils.escapeHtml(app.application || app.name || 'Application')}</div>
                    ${app.name && app.name !== app.application ? `<div class="application-name">${Utils.escapeHtml(app.name)}</div>` : ''}
                  </div>
                  ${app.status ? `
                    <span class="application-status status-${statusColor}">${Utils.escapeHtml(app.status)}</span>
                  ` : ''}
                </div>
                <div class="application-details">
                  ${app.receiptNumber ? `
                    <div class="application-detail">
                      <span class="application-detail-label">Receipt #</span>
                      <span>${Utils.escapeHtml(app.receiptNumber)}</span>
                    </div>
                  ` : ''}
                  ${app.receiptDate ? `
                    <div class="application-detail">
                      <span class="application-detail-label">Filed</span>
                      <span>${Utils.formatDate(app.receiptDate)}</span>
                    </div>
                  ` : ''}
                  ${app.matter ? `
                    <div class="application-detail">
                      <span class="application-detail-label">Matter</span>
                      <span class="event-matter-tag ${app.matter}" style="background: ${matterConfig?.color || '#6b7280'}20; color: ${matterConfig?.color || '#6b7280'}">
                        ${matterConfig?.shortLabel || app.matter}
                      </span>
                    </div>
                  ` : ''}
                </div>
              </div>
            `;
          }).join('') : '<div class="no-data">No applications found.</div>'}
        </div>
      `;
    },

    /**
     * Render structured tab content (original behavior for Client Info tab)
     */
    renderStructuredTabContent(cases, displayFields, activeTab, tabData) {
      // Filter fields based on user preferences
      const visibleFieldNames = FieldPreferences.getVisibleFields(activeTab);

      // If user has configured visible fields, filter by them
      if (visibleFieldNames.length > 0) {
        displayFields = displayFields.filter(f =>
          visibleFieldNames.includes(f.fieldName) &&
          !FieldPreferences.isAlwaysHidden(activeTab, f.fieldName)
        );
      } else {
        // Filter out always-hidden fields
        displayFields = displayFields.filter(f =>
          !FieldPreferences.isAlwaysHidden(activeTab, f.fieldName)
        );
      }

      // For Cases tab, show case filter
      const showCaseFilter = activeTab === 'cases' && cases.length > 1;
      if (showCaseFilter && this.state.selectedCase !== 'all') {
        displayFields = displayFields.filter(f =>
          !f.caseLabel || f.caseLabel === this.state.selectedCase
        );
      }

      if (!tabData || displayFields.length === 0) {
        return `<div class="no-data">No data available for this section.</div>`;
      }

      return `
        ${this.renderSettingsPanel(activeTab, tabData)}

        ${showCaseFilter ? this.renderCaseTabs(cases) : ''}

        ${this.state.viewMode === 'narrative'
          ? this.renderNarrativeView(displayFields)
          : this.renderStructuredView(displayFields)}
      `;
    },

    /**
     * Render the field customization settings panel
     */
    renderSettingsPanel(tabId, tabData) {
      const allFieldNames = [...tabData.allFieldNames].sort();
      const visibleFields = FieldPreferences.getVisibleFields(tabId);
      const hasCustomization = visibleFields.length > 0;

      return `
        <div class="settings-panel ${this.state.settingsOpen ? 'open' : ''}">
          <div class="settings-panel-header" data-action="toggle-settings">
            <span class="settings-panel-title">
              Customize Fields ${hasCustomization ? `(${visibleFields.length} selected)` : ''}
            </span>
            <span>${this.state.settingsOpen ? '‚ñº' : '‚ñ∂'}</span>
          </div>
          <div class="settings-panel-content">
            <button class="configure-layout-btn" data-action="open-field-canvas" data-tab="${tabId}">
              <span class="btn-icon">‚öôÔ∏è</span>
              Advanced Field Configuration
            </button>
            <div class="field-checkbox-list">
              ${allFieldNames.map(fieldName => {
                const isAlwaysHidden = FieldPreferences.isAlwaysHidden(tabId, fieldName);
                if (isAlwaysHidden) return '';

                const isChecked = visibleFields.length === 0 || visibleFields.includes(fieldName);
                const schemaType = SchemaProcessor.getFieldType(fieldName);
                const field = FieldRegistry.getField(fieldName);
                const tupleAddress = field?.tupleAddress || '';

                return `
                  <label class="field-checkbox-item" title="${Utils.escapeHtml(tupleAddress)}">
                    <input type="checkbox"
                           data-field="${Utils.escapeHtml(fieldName)}"
                           data-tab="${tabId}"
                           ${isChecked ? 'checked' : ''}>
                    <span>${Utils.escapeHtml(fieldName)}</span>
                    ${schemaType ? `<span class="field-type">${schemaType}</span>` : ''}
                  </label>
                `;
              }).join('')}
            </div>
            <div class="settings-actions">
              <button class="settings-btn" data-action="select-all" data-tab="${tabId}">Select All</button>
              <button class="settings-btn" data-action="select-none" data-tab="${tabId}">Select None</button>
              <button class="settings-btn" data-action="reset-defaults" data-tab="${tabId}">Reset to Defaults</button>
            </div>
          </div>
        </div>
      `;
    },

    renderCaseTabs(cases) {
      return `
        <div class="case-tabs-container">
          <div class="case-tabs-header">
            <span class="case-tabs-label">Case Master View Records</span>
          </div>
          <div class="case-tabs">
            <button class="case-tab ${this.state.selectedCase === 'all' ? 'active' : ''}" data-case="all">
              All Records<span class="case-count">${cases.length}</span>
            </button>
            ${cases.map(c => `
              <button class="case-tab ${this.state.selectedCase === c ? 'active' : ''}" data-case="${Utils.escapeHtml(c)}">
                ${Utils.escapeHtml(c)}
              </button>
            `).join('')}
          </div>
        </div>
      `;
    },

    renderNarrativeView(fields) {
      const narrative = DataProcessor.composeNarrative(fields);
      const tier2and3 = fields.filter(f => f.tier > 1);
      const grouped = DataProcessor.groupFields(tier2and3);

      return `
        <div class="narrative-view">
          <div class="narrative-text">
            ${narrative || '<em>No semantic data available for this section.</em>'}
          </div>
        </div>

        ${Object.keys(grouped).length > 0 ? `
          <div class="uncategorized-section">
            <button class="uncategorized-toggle" data-action="toggle-extra">
              <span>‚ñ∂</span>
              Additional fields (${tier2and3.length})
            </button>
            <div class="uncategorized-content" id="extra-fields">
              ${this.renderGroupedFields(grouped, true)}
            </div>
          </div>
        ` : ''}
      `;
    },

    renderStructuredView(fields) {
      // Exclude header fields from groups
      const headerRoles = CONFIG?.DISPLAY?.headerFields || [];
      const nonHeaderFields = fields.filter(f => !headerRoles.includes(f.role));
      const grouped = DataProcessor.groupFields(nonHeaderFields);

      if (Object.keys(grouped).length === 0) {
        return `<div class="no-data">No fields to display. Use the settings panel above to select fields.</div>`;
      }

      return `
        <div class="structured-view">
          ${this.renderGroupedFields(grouped, false)}
        </div>
      `;
    },

    renderGroupedFields(grouped, flat = false) {
      const groupOrder = CONFIG?.GROUP_ORDER || Object.keys(grouped);

      return groupOrder
        .filter(groupName => grouped[groupName] && grouped[groupName].length > 0)
        .map(groupName => {
          const groupFields = grouped[groupName];
          const isUncategorized = groupName === 'Uncategorized';
          const isExpanded = this.state.expandedGroups.has(groupName) || flat;

          if (flat) {
            return this.renderFlatGroup(groupName, groupFields);
          }

          return `
            <div class="field-group ${isExpanded ? '' : 'collapsed'}" data-group="${Utils.escapeHtml(groupName)}">
              <div class="field-group-header">
                <span class="field-group-title">
                  ${Utils.escapeHtml(groupName)}
                  <span class="field-group-count">(${groupFields.length})</span>
                </span>
                <span class="field-group-chevron">‚ñº</span>
              </div>
              <div class="field-group-content">
                ${isUncategorized
                  ? this.renderTriplets(groupFields)
                  : this.renderFieldItems(groupFields)}
              </div>
            </div>
          `;
        }).join('');
    },

    renderFlatGroup(groupName, fields) {
      const isUncategorized = groupName === 'Uncategorized';

      return `
        <div style="margin-bottom: 16px;">
          <div style="font-weight: 500; font-size: 12px; color: var(--text-muted); margin-bottom: 8px; text-transform: uppercase;">
            ${Utils.escapeHtml(groupName)}
          </div>
          ${isUncategorized
            ? this.renderTriplets(fields)
            : this.renderFieldItems(fields)}
        </div>
      `;
    },

    renderFieldItems(fields) {
      return fields.map(field => {
        // Use displayLabel from schema processing, or fall back to humanized field name
        const label = field.displayLabel || Utils.humanizeFieldName(field.fieldName);

        return `
          <div class="field-item">
            <span class="field-label">
              <span class="tier-indicator tier-${field.tier}" title="Tier ${field.tier}${field.schemaType ? ' | ' + field.schemaType : ''}"></span>
              ${Utils.escapeHtml(label)}
            </span>
            <span class="field-value">
              ${this.renderFieldValue(field)}
              ${this.state.showProvenance && (field.sourceTable || field.caseLabel)
                ? `<span class="provenance-badge">${Utils.escapeHtml(field.sourceTable || field.caseLabel)}</span>`
                : ''}
            </span>
          </div>
        `;
      }).join('');
    },

    renderFieldValue(field) {
      // Handle button fields
      if (field.dataType === 'button' && field.buttonUrl) {
        return `<a href="${Utils.escapeHtml(field.buttonUrl)}" target="_blank" rel="noopener" class="button-link">${Utils.escapeHtml(field.buttonLabel || 'Open')} ‚Üó</a>`;
      }

      // Handle attachment fields
      if (field.dataType === 'attachment' && field.buttonUrl) {
        const icon = field.fileType?.includes('pdf') ? 'üìÑ' : 'üìé';
        return `<a href="${Utils.escapeHtml(field.buttonUrl)}" target="_blank" rel="noopener" class="button-link">${icon} ${Utils.escapeHtml(field.buttonLabel || 'Download')}</a>`;
      }

      const value = field.rendered || field.value;

      // Check if it's a URL
      if (field.dataType === 'url' || /^https?:\/\//.test(String(value))) {
        return `<a href="${Utils.escapeHtml(value)}" target="_blank" rel="noopener">Link ‚Üó</a>`;
      }

      // Truncate long values
      const strValue = String(value);
      if (strValue.length > 100) {
        return `<span title="${Utils.escapeHtml(strValue)}">${Utils.escapeHtml(strValue.slice(0, 100))}‚Ä¶</span>`;
      }

      return Utils.escapeHtml(strValue);
    },

    renderTriplets(fields) {
      return fields.map(field => `
        <div class="triplet">
          <span class="triplet-source">[${Utils.escapeHtml(field.caseLabel || field.sourceTable)}]</span>
          <span class="triplet-field">${Utils.escapeHtml(field.fieldName)}</span>
          <span class="triplet-value">${this.renderFieldValue(field)}</span>
        </div>
      `).join('');
    },

    attachEventListeners() {
      // View toggle
      document.querySelectorAll('.view-toggle button').forEach(btn => {
        btn.addEventListener('click', (e) => {
          this.state.viewMode = e.currentTarget.dataset.view;
          this.render();
        });
      });

      // Narrative mode toggle (short/long)
      document.querySelectorAll('.narrative-toggle button').forEach(btn => {
        btn.addEventListener('click', (e) => {
          this.state.narrativeMode = e.currentTarget.dataset.narrative;
          this.render();
        });
      });

      // Main tabs
      document.querySelectorAll('.main-tab').forEach(btn => {
        btn.addEventListener('click', (e) => {
          this.state.activeMainTab = e.currentTarget.dataset.mainTab;
          this.state.settingsOpen = false; // Close settings when switching tabs
          this.render();
        });
      });

      // Matter pills (filter by matter type)
      document.querySelectorAll('.matter-pill').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const matter = e.currentTarget.dataset.matter;
          if (matter === 'clear' || this.state.selectedMatter === matter) {
            this.state.selectedMatter = null;
          } else {
            this.state.selectedMatter = matter;
          }
          this.render();
        });
      });

      // Matter cards (click to filter to that matter)
      document.querySelectorAll('.matter-card').forEach(card => {
        card.addEventListener('click', (e) => {
          const matter = e.currentTarget.dataset.matterCard;
          if (matter) {
            this.state.selectedMatter = matter;
            this.state.activeMainTab = 'matters';
            this.render();
          }
        });
      });

      // Note expansion
      document.querySelectorAll('[data-action="expand-note"]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const noteCard = e.target.closest('.note-card');
          const noteContent = noteCard.querySelector('.note-content');
          if (noteContent.classList.contains('truncated')) {
            noteContent.classList.remove('truncated');
            noteContent.textContent = noteContent.dataset.full;
            e.target.textContent = 'Show less';
          } else {
            noteContent.classList.add('truncated');
            noteContent.textContent = noteContent.dataset.full.slice(0, 300) + '...';
            e.target.textContent = 'Read more';
          }
        });
      });

      // Case tabs (within Cases tab)
      document.querySelectorAll('.case-tab').forEach(btn => {
        btn.addEventListener('click', (e) => {
          this.state.selectedCase = e.currentTarget.dataset.case;
          this.render();
        });
      });

      // Settings panel toggle
      const settingsToggle = document.querySelector('[data-action="toggle-settings"]');
      if (settingsToggle) {
        settingsToggle.addEventListener('click', () => {
          this.state.settingsOpen = !this.state.settingsOpen;
          this.render();
        });
      }

      // Open Field Canvas button
      document.querySelectorAll('[data-action="open-field-canvas"]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const tabId = e.currentTarget.dataset.tab;
          FieldCanvas.open(tabId);
        });
      });

      // Field checkboxes
      document.querySelectorAll('.field-checkbox-item input').forEach(checkbox => {
        checkbox.addEventListener('change', (e) => {
          const fieldName = e.target.dataset.field;
          const tabId = e.target.dataset.tab;
          const checked = e.target.checked;

          // Get current visible fields
          const currentVisible = FieldPreferences.getVisibleFields(tabId);

          // If no customization yet, start with all fields
          if (currentVisible.length === 0) {
            const allFields = [...this.tabData[tabId].allFieldNames].filter(
              f => !FieldPreferences.isAlwaysHidden(tabId, f)
            );
            if (checked) {
              // Already showing all, nothing to do
            } else {
              // Remove this field from all
              const newVisible = allFields.filter(f => f !== fieldName);
              FieldPreferences.setVisibleFields(tabId, newVisible);
            }
          } else {
            // Toggle the field
            FieldPreferences.toggleField(tabId, fieldName, checked);
          }

          this.render();
        });
      });

      // Select All button
      document.querySelectorAll('[data-action="select-all"]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const tabId = e.target.dataset.tab;
          const allFields = [...this.tabData[tabId].allFieldNames].filter(
            f => !FieldPreferences.isAlwaysHidden(tabId, f)
          );
          FieldPreferences.setVisibleFields(tabId, allFields);
          this.render();
        });
      });

      // Select None button
      document.querySelectorAll('[data-action="select-none"]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const tabId = e.target.dataset.tab;
          FieldPreferences.setVisibleFields(tabId, []);
          this.render();
        });
      });

      // Reset to Defaults button
      document.querySelectorAll('[data-action="reset-defaults"]').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const tabId = e.target.dataset.tab;
          const defaults = CONFIG?.MAIN_TABS?.[tabId]?.defaultFields || [];
          FieldPreferences.setVisibleFields(tabId, defaults);
          this.render();
        });
      });

      // Group expand/collapse
      document.querySelectorAll('.field-group-header').forEach(header => {
        header.addEventListener('click', (e) => {
          const group = e.currentTarget.parentElement;
          const groupName = group.dataset.group;

          if (this.state.expandedGroups.has(groupName)) {
            this.state.expandedGroups.delete(groupName);
          } else {
            this.state.expandedGroups.add(groupName);
          }

          group.classList.toggle('collapsed');
        });
      });

      // Extra fields toggle
      const extraToggle = document.querySelector('[data-action="toggle-extra"]');
      if (extraToggle) {
        extraToggle.addEventListener('click', () => {
          const content = document.getElementById('extra-fields');
          content.classList.toggle('visible');
          extraToggle.querySelector('span').textContent = content.classList.contains('visible') ? '‚ñº' : '‚ñ∂';
        });
      }

      // Settings toggles (provenance)
      document.querySelectorAll('[data-setting]').forEach(input => {
        input.addEventListener('change', (e) => {
          if (e.target.dataset.setting === 'provenance') {
            this.state.showProvenance = e.target.checked;
            this.render();
          }
        });
      });
    }
  };

  // ==========================================================================
  // GOOGLE CALENDAR PARSER
  // ==========================================================================

  const GoogleCalendarParser = {
    /**
     * Parse Google Calendar events from JSON data
     * Supports both raw Google Calendar API format and flattened formats
     */
    parseEvents(data) {
      if (!data) return [];

      const events = [];

      // Handle array of events
      const items = Array.isArray(data) ? data : (data.items || data.events || [data]);

      for (const item of items) {
        const event = this.parseEvent(item);
        if (event) {
          events.push(event);
        }
      }

      // Sort by start date
      events.sort((a, b) => new Date(a.date) - new Date(b.date));

      return events;
    },

    /**
     * Parse a single calendar event
     */
    parseEvent(item) {
      if (!item) return null;

      // Extract start date/time - Google Calendar format
      let date = null;
      let isAllDay = false;

      if (item.start) {
        // Google Calendar API format: { dateTime: "...", date: "..." }
        date = item.start.dateTime || item.start.date;
        isAllDay = !item.start.dateTime && !!item.start.date;
      } else {
        // Flattened formats
        date = item['Hearing Date/Time'] || item['Event Date'] || item['Start'] ||
               item['start'] || item['startTime'] || item['date'] ||
               item['Created At'] || item['createdTime'] || item['Date'];
      }

      // Extract end date/time
      let endDate = null;
      if (item.end) {
        endDate = item.end.dateTime || item.end.date;
      } else {
        endDate = item['End'] || item['end'] || item['endTime'] || item['End Date'];
      }

      // Extract event title/summary
      const title = item.summary || item.title || item['Event Name'] ||
                    item['Activity'] || item['Subject'] || item['Name'] ||
                    item['Hearing Type'] || item['Event Hearing Type'] ||
                    item['Description'] || 'Calendar Event';

      // Extract location
      const location = item.location || item['Location'] || item['Court/Office'] ||
                       item['Venue'] || item['Place'] || '';

      // Extract description/details
      const description = item.description || item['Details'] || item['Case Notes'] ||
                          item['Notes'] || item['Hearing Notes'] || '';

      // Extract attendees
      const attendees = this.parseAttendees(item.attendees || item['Attendees'] || []);

      // Extract organizer
      const organizer = item.organizer?.email || item.organizer?.displayName ||
                        item['Organizer'] || item['MCH Attny'] || item['Judge'] || '';

      // Extract event type/category
      const eventType = item['Event Hearing Type'] || item['Hearing Type'] ||
                        item['eventType'] || item['type'] || item['Category'] || 'event';

      // Extract status
      const status = item.status || item['Status'] || 'confirmed';

      // Extract unique ID
      const id = item.id || item['id'] || item['Event Id'] ||
                 item['Record ID'] || `gcal-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

      // Extract HTML link
      const htmlLink = item.htmlLink || item['Link'] || item['Calendar Link'] || '';

      // Extract recurrence info
      const isRecurring = !!(item.recurrence || item.recurringEventId || item['Recurring']);

      // Calculate urgency based on date
      const urgency = date ? MatterDetector.getDateUrgency(date) : 'unknown';

      // Try to infer matter type from event content
      const matter = this.inferMatterFromEvent(title, description, eventType);

      return {
        id,
        date,
        endDate,
        title,
        location,
        description,
        attendees,
        organizer,
        eventType,
        status,
        htmlLink,
        isAllDay,
        isRecurring,
        urgency,
        matter,
        source: 'google_calendar',
        group: 'Calendar',
        fields: item // Keep original fields for reference
      };
    },

    /**
     * Parse attendees list
     */
    parseAttendees(attendees) {
      if (!attendees || !Array.isArray(attendees)) return [];

      return attendees.map(a => ({
        email: a.email || a['Email'] || '',
        name: a.displayName || a['Name'] || a.email || '',
        responseStatus: a.responseStatus || a['Response'] || 'needsAction',
        self: a.self || false
      }));
    },

    /**
     * Try to infer matter type from event content
     */
    inferMatterFromEvent(title, description, eventType) {
      const combined = `${title} ${description} ${eventType}`.toLowerCase();

      if (/sij|juvenile|custody|jdr/i.test(combined)) return 'sij';
      if (/asylum|i-589|fear|persecution/i.test(combined)) return 'asylum';
      if (/u-visa|u visa|uvisa|certification/i.test(combined)) return 'uvisa';
      if (/bond|detention|custody.*ice/i.test(combined)) return 'bond';
      if (/removal|deportation|eoir/i.test(combined)) return 'removal';
      if (/family|i-130|relative|spouse/i.test(combined)) return 'family';

      return null;
    },

    /**
     * Format event for display
     */
    formatEventForDisplay(event) {
      return {
        ...event,
        formattedDate: Utils.formatDate(event.date, !event.isAllDay),
        formattedEndDate: event.endDate ? Utils.formatDate(event.endDate, !event.isAllDay) : null,
        displayTitle: event.title,
        displayLocation: event.location,
        displayDescription: event.description ?
          (event.description.length > 200 ? event.description.substring(0, 200) + '...' : event.description) : ''
      };
    }
  };

  // ==========================================================================
  // DATA FETCHER
  // ==========================================================================

  const DataFetcher = {
    async fetchClientData(recordId) {
      // For development/demo, check for mock data
      if (window.MOCK_DATA) {
        // Initialize schema if provided separately
        if (window.MOCK_SCHEMA && !SchemaProcessor.hasSchema()) {
          SchemaProcessor.init(window.MOCK_SCHEMA);
        }
        return window.MOCK_DATA;
      }

      const url = `${WEBHOOK_URL}?recordId=${encodeURIComponent(recordId)}`;
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Accept': 'application/json'
        }
      });

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return response.json();
    },

    /**
     * Fetch Google Calendar events
     * Can be provided via window.GOOGLE_CALENDAR_DATA or fetched from API
     */
    async fetchCalendarEvents(calendarId = null) {
      // Check for mock/provided calendar data
      if (window.GOOGLE_CALENDAR_DATA) {
        console.log('[DataFetcher] Using provided Google Calendar data');
        return GoogleCalendarParser.parseEvents(window.GOOGLE_CALENDAR_DATA);
      }

      // Check if calendar data is embedded in the main data
      if (window.MOCK_DATA) {
        const calendarEvents = this.extractCalendarEventsFromData(window.MOCK_DATA);
        if (calendarEvents.length > 0) {
          console.log('[DataFetcher] Extracted', calendarEvents.length, 'calendar events from data');
          return calendarEvents;
        }
      }

      console.log('[DataFetcher] No Google Calendar data available');
      return [];
    },

    /**
     * Extract calendar-like events from the main data
     */
    extractCalendarEventsFromData(data) {
      if (!Array.isArray(data)) return [];

      const events = [];

      for (const record of data) {
        // Look for event-like records (have date + title/activity)
        const hasDate = record['Hearing Date/Time'] || record['Event Date'] ||
                        record['start'] || record['Start'] || record['date'];
        const hasTitle = record['Activity'] || record['Event Name'] ||
                         record['summary'] || record['Subject'] || record['title'];

        // Only extract as calendar event if it looks like an event record
        if (hasDate && hasTitle) {
          const event = GoogleCalendarParser.parseEvent(record);
          if (event) {
            events.push(event);
          }
        }
      }

      return events;
    }
  };

  // ==========================================================================
  // INITIALIZATION
  // ==========================================================================

  async function init() {
    const container = document.getElementById('app');

    try {
      // Check for config
      if (!CONFIG) {
        throw new Error('Configuration not loaded. Make sure config.js is included.');
      }

      // Initialize schema if provided globally (for testing/development)
      if (window.MOCK_SCHEMA && !SchemaProcessor.hasSchema()) {
        console.log('[init] Initializing schema from MOCK_SCHEMA');
        SchemaProcessor.init(window.MOCK_SCHEMA);
      }

      // Get record ID - wait briefly for postMessage if in iframe context
      let recordId = Utils.getRecordId();

      // If no recordId and we might be in an iframe, wait briefly for postMessage
      if (!recordId && !window.MOCK_DATA && window.parent !== window) {
        console.log('[init] No recordId found, waiting for postMessage...');
        container.innerHTML = `<div class="loading"><div>Waiting for data...</div></div>`;

        // Wait up to 500ms for postMessage
        await new Promise(resolve => {
          const checkInterval = setInterval(() => {
            if (postMessageRecordId) {
              clearInterval(checkInterval);
              resolve();
            }
          }, 50);
          setTimeout(() => {
            clearInterval(checkInterval);
            resolve();
          }, 500);
        });

        recordId = Utils.getRecordId();
      }

      if (!recordId && !window.MOCK_DATA) {
        container.innerHTML = `
          <div class="error">
            <div class="error-title">No Record ID</div>
            <div>Please provide a recordId parameter in the URL.</div>
          </div>
        `;
        return;
      }

      // Show loading state
      container.innerHTML = `
        <div class="loading">
          <div>Loading client data...</div>
          ${SchemaProcessor.hasSchema() ? '<div class="loading-detail">Schema loaded</div>' : ''}
        </div>
      `;

      // Fetch data
      const data = await DataFetcher.fetchClientData(recordId);

      // Log schema status
      console.log('[init] Schema status:', SchemaProcessor.hasSchema() ? 'loaded' : 'not loaded');

      // Initialize renderer
      Renderer.init(data);

    } catch (error) {
      console.error('Client Glance Error:', error);
      container.innerHTML = `
        <div class="error">
          <div class="error-title">Error Loading Data</div>
          <div>${Utils.escapeHtml(error.message)}</div>
        </div>
      `;
    }
  }

  // Auto-expand first few groups in structured view
  Renderer.state.expandedGroups.add('Calendar');
  Renderer.state.expandedGroups.add('Court');
  Renderer.state.expandedGroups.add('SIJ');
  Renderer.state.expandedGroups.add('USCIS');
  Renderer.state.expandedGroups.add('Identity');
  Renderer.state.expandedGroups.add('Contact');

  // Set default tab to overview
  Renderer.state.activeMainTab = 'overview';

  // Initialize when DOM ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }

  // Expose for debugging
  window.ClientGlance = { Utils, DataProcessor, Renderer, DataFetcher, SchemaProcessor, DataTransformer };

})();
</script>

</body>
</html>
